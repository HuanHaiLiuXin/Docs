## 1.Java代码是怎么运行的
#### 1.Java代码运行于Java虚拟机中
#### 2.Java代码为何要运行在虚拟机中
1. 之所以Java代码要运行于虚拟机中,是为了实现其可移植性/跨平台.只要Java代码被编译为字节码(.class文件),就可以在不同平台的Java虚拟机上运行;"一次编写,到处运行".
2. Java虚拟机还提供了1个代码托管的环境,替我们实现自动内存管理和垃圾回收等功能.
#### 3.Java代码执行大致流程
1. 首先通过编译期将Java源文件编译为Java虚拟机可以识别的字节码(.class文件).
2. Java虚拟机加载class文件,加载后的Java类会被存放于方法区.实际运行时,Java虚拟机会执行方法区中的代码.
    1. 从硬件角度看,Java字节码无法直接执行,JVM需要将字节码翻译成机器码
    2. 标准JDK的HotSpot虚拟机采用了2种方式将字节码翻译成机器码
        1. 解释执行:即逐条将字节码翻译成机器码并执行
        2. 即时编译/JIT:即将1个方法中所有的字节码翻译成机器码后再执行
            1. 即时编译的时间开销
                - 解释执行流程:输入的代码 -> [ 解释器 解释执行 ] -> 执行结果
                - 即时编译流程:输入的代码 -> [ 编译器 编译 ] -> 编译后的代码 -> [ 执行编译后的代码 ] -> 执行结果
                - 说JIT比解释快,说的是“执行编译后的代码”比“解释器解释执行”要快,并不是1次即时编译流程比1次解释执行流程更快.对“只执行一次”的代码而言,解释执行其实总是比JIT编译执行要快
                - 即时编译后的代码会保存在内存中,只有对频繁执行的代码,JIT编译才能保证有正面的收益
            2. 即时编译的空间开销
                - 对一般的Java方法,即时编译后代码的大小相对于字节码的大小,膨胀比达到10x是很正常
                - 只有对执行频繁的代码才值得编译,如果把所有代码都编译则会显著增加代码所占空间,导致“代码爆炸”
        3. 解释执行的优势在于节约内存,无需等待编译;即时编译的优势在于频繁调用的代码字节码翻译成机器码后再执行,实际运行速度更快,但内存开销更大.
        4. 为了提高运行效率,HotSpot采用的是一种混合执行的策略:它会解释执行字节码,然后会将其中反复执行的热点代码,以方法为单位进行即时编译,翻译成机器码后直接运行在底层硬件之上.
![](https://user-gold-cdn.xitu.io/2018/8/27/1657add6d3729800?w=1918&h=1076&f=png&s=121552)
#### 4.JVM中的 运行时内存区域 结构
![](https://user-gold-cdn.xitu.io/2018/8/27/1657a64e8cabf87f?w=1916&h=1074&f=png&s=122919)
**方法区和堆是所有线程共享;PC寄存器,Java方法栈,本地方法栈是每个线程私有.**<br>
1. 方法区
    1. 方法区Method Area是各个线程共享的内存区域,必须保证线程安全
        > 如两个类要同时加载1个尚未被加载的类C,1个类会请求ClassLoader去加载类C,另1个类只能等待C加载完成而不会重复加载
    2. 方法区存储已被加载的类的信息,常量,静态变量,即时编译器编译后的代码等.
2. 堆
    1. 堆是JVM管理的内存中最大的一块,被所有线程共享,在JVM启动时创建,非线程安全.
    2. 堆存在的目的就是为了存放对象实例.
    3. 堆是垃圾收集器管理的主要区域.从内存回收的角度看,现在的垃圾收集器都基于分代回收算法,Java堆可以进一步细分.
3. PC寄存器/程序计数器
    1. PC寄存器是一块较小的内存空间,用于记录当前线程正在执行的虚拟机字节码的地址;
    2. Java虚拟机的多线程是通过线程轮流切换分配处理器执行时间来实现,在任何1个确定时刻,一个CPU/多核CPU中的1个核只能执行1条线程的指令.
    3. 当有多个线程交叉执行时,被中断的线程当前执行到哪个字节码内存地址必然要保存下来,以便用于被中断的线程恢复执行时继续执行.每个线程都有一个独立的PC寄存器,多线程之间互不影响.
4. Java方法栈
    1. Java方法栈是线程私有的,所以不需要关心数据一致性,也不存在同步锁问题.
    2. 每当创建1个线程,JVM就会为其创建对应的Java方法栈.
    3. Java方法栈中包含多个栈帧.
        1. 每个栈帧关联了1个Java方法,每运行1个方法,就创建1个栈帧,栈帧包含了关联方法的信息.
        2. 每当1个方法执行完毕,该栈帧就会弹出栈帧的元素作为方法的返回值,并清理栈帧.Java方法栈的栈顶就是当前正在执行的方法,PC寄存器记录的也是这个地址.
        3. Java方法栈的栈顶的栈帧A调用新方法,会创建新的对应栈帧B压入栈顶,B执行完毕后,B被移除,B的返回值作为A的1个操作数,继续执行A
    4. JVM规范规定了Java方法栈中的2中异常
        1. 如果线程请求的栈深度大于虚拟机所允许的深度,将抛出StackOverflowError异常
        2. 如果虚拟机可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常
5. 本地方法栈/Native Method Stack
    1. 本地方法栈Java方法栈所发挥的作用是非常相似的,其区别不过是Java方法栈为虚拟机执行Java方法服务,而本地方法栈则是为虚拟机使用到的Native方法服务
    2. 本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常
