## 1.Java代码是怎么运行的
#### 1.Java代码运行于Java虚拟机中
#### 2.Java代码为何要运行在虚拟机中
1. 之所以Java代码要运行于虚拟机中,是为了实现其可移植性/跨平台.只要Java代码被编译为字节码(.class文件),就可以在不同平台的Java虚拟机上运行;"一次编写,到处运行".
2. Java虚拟机还提供了1个代码托管的环境,替我们实现自动内存管理和垃圾回收等功能.
#### 3.Java代码执行大致流程
1. 首先通过编译期将Java源文件编译为Java虚拟机可以识别的字节码(.class文件).
2. Java虚拟机加载class文件,加载后的Java类会被存放于方法区.实际运行时,Java虚拟机会执行方法区中的代码.
    1. 从硬件角度看,Java字节码无法直接执行,JVM需要将字节码翻译成机器码
    2. 标准JDK的HotSpot虚拟机采用了2种方式将字节码翻译成机器码
        1. 解释执行:即逐条将字节码翻译成机器码并执行
        2. 即时编译/JIT:即将1个方法中所有的字节码翻译成机器码后再执行
            1. 即时编译的时间开销
                - 解释执行流程:输入的代码 -> [ 解释器 解释执行 ] -> 执行结果
                - 即时编译流程:输入的代码 -> [ 编译器 编译 ] -> 编译后的代码 -> [ 执行编译后的代码 ] -> 执行结果
                - 说JIT比解释快,说的是“执行编译后的代码”比“解释器解释执行”要快,并不是1次即时编译流程比1次解释执行流程更快.对“只执行一次”的代码而言,解释执行其实总是比JIT编译执行要快
                - 即时编译后的代码会保存在内存中,只有对频繁执行的代码,JIT编译才能保证有正面的收益
            2. 即时编译的空间开销
                - 对一般的Java方法,即时编译后代码的大小相对于字节码的大小,膨胀比达到10x是很正常
                - 只有对执行频繁的代码才值得编译,如果把所有代码都编译则会显著增加代码所占空间,导致“代码爆炸”
        3. 解释执行的优势在于节约内存,无需等待编译;即时编译的优势在于频繁调用的代码字节码翻译成机器码后再执行,实际运行速度更快,但内存开销更大.
        4. 为了提高运行效率,HotSpot采用的是一种混合执行的策略:它会解释执行字节码,然后会将其中反复执行的热点代码,以方法为单位进行即时编译,翻译成机器码后直接运行在底层硬件之上.
![](https://user-gold-cdn.xitu.io/2018/8/27/1657add6d3729800?w=1918&h=1076&f=png&s=121552)
#### 4.JVM中的 运行时内存区域 结构
![](https://user-gold-cdn.xitu.io/2018/8/27/1657a64e8cabf87f?w=1916&h=1074&f=png&s=122919)
**方法区和堆是所有线程共享;PC寄存器,Java方法栈,本地方法栈是每个线程私有.**<br>
1. 方法区
    1. 方法区Method Area是各个线程共享的内存区域,必须保证线程安全
        > 如两个类要同时加载1个尚未被加载的类C,1个类会请求ClassLoader去加载类C,另1个类只能等待C加载完成而不会重复加载
    2. 方法区存储已被加载的类的信息,常量,静态变量,即时编译器编译后的代码等.
2. 堆
    1. 堆是JVM管理的内存中最大的一块,被所有线程共享,在JVM启动时创建,非线程安全.
    2. 堆存在的目的就是为了存放对象实例.
    3. 堆是垃圾收集器管理的主要区域.从内存回收的角度看,现在的垃圾收集器都基于分代回收算法,Java堆可以进一步细分.
3. PC寄存器/程序计数器
    1. PC寄存器是一块较小的内存空间,用于记录当前线程正在执行的虚拟机字节码的地址;
    2. Java虚拟机的多线程是通过线程轮流切换分配处理器执行时间来实现,在任何1个确定时刻,一个CPU/多核CPU中的1个核只能执行1条线程的指令.
    3. 当有多个线程交叉执行时,被中断的线程当前执行到哪个字节码内存地址必然要保存下来,以便用于被中断的线程恢复执行时继续执行.每个线程都有一个独立的PC寄存器,多线程之间互不影响.
4. Java方法栈
    1. Java方法栈是线程私有的,所以不需要关心数据一致性,也不存在同步锁问题.
    2. 每当创建1个线程,JVM就会为其创建对应的Java方法栈.
    3. Java方法栈中包含多个栈帧.
        1. 每个栈帧关联了1个Java方法,每运行1个方法,就创建1个栈帧,栈帧包含了关联方法的信息.
        2. 每当1个方法执行完毕,该栈帧就会弹出栈帧的元素作为方法的返回值,并清理栈帧.Java方法栈的栈顶就是当前正在执行的方法,PC寄存器记录的也是这个地址.
        3. Java方法栈的栈顶的栈帧A调用新方法,会创建新的对应栈帧B压入栈顶,B执行完毕后,B被移除,B的返回值作为A的1个操作数,继续执行A
    4. JVM规范规定了Java方法栈中的2中异常
        1. 如果线程请求的栈深度大于虚拟机所允许的深度,将抛出StackOverflowError异常
        2. 如果虚拟机可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常
5. 本地方法栈/Native Method Stack
    1. 本地方法栈Java方法栈所发挥的作用是非常相似的,其区别不过是Java方法栈为虚拟机执行Java方法服务,而本地方法栈则是为虚拟机使用到的Native方法服务
    2. 本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常

## 2.Java的基本类型
#### 1.JVM的boolean类型
1. 在JVM规范中,boolean类型被映射为int类型.true被映射为1,false被映射为0.
2. 实例:
    ```java
    public class T3 {
    	boolean tag = true;
    	public static void main(String[] args) {
    		T3 t = new T3();
    		t.t();
    	}
    	private void t(){
    	        //1:tag不是0吧?
    		if(tag){
    			System.out.println("tag不是0");
    		}
    		//2:tag真的是1吗?
    		if(true == tag){
    			System.out.println("tag真的是1");
    		}
    	}
    }
    
    打印结果:
    tag不是0
    tag真的是1
    ```
    在经过编译后,上面的代码对于JVM的实际逻辑是:<br>
    1. tag不是0吧?如果tag对应的是2,3等其他非0整数,也一样会打印
    2. tag真的是1吗?因为true在JVM中对应的就是1,只要tag对应的整数不是1,就无法和true(1)相等.
#### 2.Java的基本类型
Java的8种基本类型,在JVM内存中,8种基本类型的默认值都是0
#### 3.Float.NaN很特殊:Float.NaN不和任何float值相等,包括自身,除了“!=”始终返回true,所有其他比较结果都会返false
```java
float f = Float.intBitsToFloat(0x7fc00000);
System.out.println("f:"+f);
System.out.println("NaN>=1.0F:"+(f>=1.0F));
System.out.println("NaN<=1.0F:"+(f<=1.0F));
float NaN = Float.NaN;
System.out.println("NaN==Float.NaN:"+(NaN==Float.NaN));
System.out.println("NaN!=Float.NaN:"+(NaN!=Float.NaN));

打印结果:
f:NaN
NaN>=1.0F:false
NaN<=1.0F:false
NaN==Float.NaN:false
NaN!=Float.NaN:true
```
## 3.JVM类加载过程
#### 1.Java语言的类型
1. 8种基本类型
2. 引用类型
    1. 类
    2. 接口
    3. 数组类
    4. 泛型参数
3. JVM中存在几种:3种
    1. 8种基本类型是由JVM预先定义好的
    2. 泛型参数会在编译过程中被擦除
    3. JVM中只存在 类,接口,数组类
        1. 数组类由JVM直接生成
        2. 类,接口则有对应的字节流
        3. 字节流最常见的形式就是.class文件
#### 2.从.class文件到内存中的类,按先后顺序需要经过 加载-->链接-->初始化 3大步骤
1. 加载:就是查找字节流,并且根据字节流创建类的过程
    1. 上面可知,基本类型JVM预先定义好了,泛型参数被擦除,数组类由JVM直接生成,因而记载涉及的只是: 类 及 接口.
    2. JVM需要借助类加载器完成查找字节流的过程
    3. 最重要的3个类加载器
        1. 启动类加载器:boat class loader
            1. 是所有类加载器的祖师爷;
            2. 除了启动类加载器,其他类加载器都是java.lang.classLoader的子类,都需要由另外的类加载器,比如boot class loader将其加载到JVM中,才能执行类的加载;
            2. 在Java 9之前,启动类加载器用于加载最基础,最重要的类
            3. 从Java 9开始引入模块系统,启动类加载器只加载少数几个关键模块
        2. 扩展类加载器:extension class loader
            1. 扩展类加载器的父类加载器是 启动类加载器.
            2. 在Java 9之前,扩展类加载器用于加载相对重要,但又通用的类
            3. 从Java 9开始引入模块系统,扩展类加载器改名为 平台类加载器:platform class loader,除了少数几个关键模块由启动类加载器加载,其他模块都由平台类加载器加载
        3. 应用类加载器:application class loader
            1. application class loader的父类加载器是 extension class loader
            2. 负责加载应用程序路径下的类,默认情况下,应用程序中包含的类就由应用类加载器加载
    4. 除了加载功能,类加载器还提供了命名空间的作用.
        - 在JVM中,类的唯一性是由类加载器实例及类的全名共同确定.即使是同一串字节流,由2个类加载器加载,JVM也将其当做两个不同的类.
    5. 类加载器加载类有1个规则:双亲委派模型
        1. 如果一个类加载器收到类加载的请求,它首先不会自己去尝试加载这个类,而是把这个请求委派给父类加载器完成.每个类加载器都是如此,只有当父加载器在自己的搜索范围内找不到指定的类时,子加载器才会尝试自己去加载.
        2. 双亲委派模型具体流程
            1. 当application class loader收到1个类C的加载请求,它首先不会自己尝试加载C,而是委派给父类加载器 extension class loader去加载C
            2. 当extension class loader收到C的加载请求,它首先也不会自己尝试加载,而是委派给父类加载器 boot class loader去加载C
            3. boot class loader没有父类加载器,直接尝试加载C.
                - 如果C加载成功,加载过程就完成
                - 如果C加载失败,则丢回给子类 extension class loader 加载
            4. extension class loader尝试加载C.
                - 如果C加载成功,完成
                - 如果C加载失败,则丢回给子类 application class loader 加载
            5. application class loader尝试加载C.
                - 如果C加载成功,完成
                - 如果C加载失败,则使用自定义加载器加载
            6. 自定义类加载器尝试加载C
                - 如果C加载成功,完成
                - 如果C加载失败,则抛出ClassNotFoundException异常
        3. 双亲委派模型的意义:确保了类加载器加载类的优先级,防止恶意伪造的系统类被加载,保证了安全.
2. 链接:是指将创建成功的类合并至JVM中,使之能够执行的过程.分为 验证,准备,解析 三个阶段.
    1. 验证
        - 验证的目的是确保被加载的类满足JVM的约束条件,一般Java编译器生成的类文件必然满足约束条件.
    2. 准备
        1. 准备阶段为被加载的类的静态字段分配内存.
        2. 仅仅是分配内存,静态字段具体初始化/赋值则是在初始化阶段进行
    3. 解析
        1. 在class文件被加载至JVM之前,这个类C无法知道其他类O及O中的方法和字段对应的地址,甚至不知道自己的方法,字段的地址;每当需要引用这些还不知道地址的成员,Java编译器会生成1个符号引用.
        2. 解析阶段的作用,正是将这些符号引用解析为实际引用.
            1. 比如符号引用指向了1个未被加载的类S,或执行S的字段或方法,那么解析阶段将触发S的加载.
            2. 仅仅触发符号引用指向的未被加载的类的加载,未必会触发其 链接 及 初始化.
3. 初始化:类加载的最后一步即为 初始化
    1. 
