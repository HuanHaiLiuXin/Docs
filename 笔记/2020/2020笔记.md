#### 1.HTTP报文Header中Host
不是在网络上用于寻址的,而是在目标服务器上用于定位子服务器的.

#### 2.对称加密
1个密钥+2个算法(加密算法,解密算法)
<br>
明文-->(密钥+加密算法)-->密文
<br>
密文-->(密钥+解密算法)-->明文

#### 3.非对称加密
2个密钥(公钥+私钥)+1个加密算法
<br>
A发送数据给B:
<br>
A:明文-->(B的公钥+加密算法)-->密文 ==> B:(B的私钥+加密算法)-->明文
<br>
非对称加密:公钥和私钥互相可解.公钥发给对方,私钥自己保管.

#### 4.编码
把数据从一种数据形式转换为另一种数据形式,如Base64.<br>
编码一定有解码与之对应.

#### 5.Http确认授权的2种方式
1.通过Cokkie
<br>
2.通过Header中添加Authorization
<br>
Authorization两种主流方式:Basic , Bearer
<br>
Authorization: Basic username:password执行Base64编码的字符串
<br>
如:Authorization: Basic 12345678
<br>
Authorization: Bearer bearer token
<br>
bearer token 需要通过 OAuth2的授权流程获取.
- 第三方网站向授权方网站申请第三方授权合作,拿到**client id和client secret.client secret需要绝对保密**,一直存在第三方网站服务器.
- 用户使用掘金,点击GitHub登录,首先跳转到GitHub网站,并将client id传入.
- GitHub根据client id,将掘金信息及掘金需要的GitHub用户的权限进行展示,询问用户是否同意
- 用户点击'同意',GitHub重新跳转回掘金,并传入**Authorization code**作为用户同意凭证.
- 掘金将Authorization code发送回掘金自己服务器
- 掘金服务器将Authorization code及client secret一并发送给GitHub服务器(**这个连接一定是HTTPS连接,是绝对安全的**),GitHub验证通过,则返回access token/bearer token.
- 掘金获取到access token,就向GitHub发送请求,用于获取该用户的信息/操作用户账户.

#### 6.Https证书验证
比如A想访问B网站,B网站的证书是BA;
<br>
A在在发送请求路程中间,被C网站截获,C网站将自己的证书CA返回给A.
<br>
CA本身也是一个合法的证书,A怎么去辨认?
<br>
**通过证书信息中的域名(host)去辨认**.比如A要访问alibaba,结果被tencent截获,返回了tencent的证书,虽然tencent证书本身合法,但是tencent的证书信息中,host是tencent,不是alibaba,和A要访问的域名不一致,就不会进行后续的验证工作.
<br>
**证书不能伪造,也不能篡改.因为证书签发机构的私钥第三方是拿不到的**,改了任何信息,都会导致修改后信息的HASH和证书签名被签发机构公钥运算后的结果对不上,导致认证失败!

#### 7.Retrofit
- 常见使用方法
    ```
    public class Student{
        ****
    }
    public interface StudentService{
        @GET("students/{gender}")
        Call<List<Student>> gainStudents(@Path("gender") String gengderValue);
    }
    Retrofit retrofit = new Retrofit.Builder()
        .baseUrl("https://services.students.com/")
        .build();
    StudentService service = retrofit.create(StudentService.class);
    Call<List<Student>> students = service.gainStudents("男");
    students.enqueue(new Callback<List<Student>>(){
        @Override
        public void onResponse(Call<List<Student>> call, Response<List<Student>> response) {
        }
        @Override
        public void onFailure(Call<List<Student>> call, Throwable t) {
        }
    });
    ```
- Retrofit.create(Class)创建出Service接口实例,是Retrofit代码结构的核心.
    ```
    retrofit-2.7.1-sources.jar!\retrofit2\Retrofit.java
    public <T> T create(final Class<T> service) {
        validateServiceInterface(service);
        return (T) Proxy.newProxyInstance(
            service.getClassLoader(), 
            new Class<?>[]{service },
            new InvocationHandler() {
                private final Platform platform = Platform.get();
                private final Object[] emptyArgs = new Object[0];
                @Override 
                public @Nullable Object invoke(Object proxy, Method method,@Nullable Object[] args) throws Throwable {
                    //如果method是Object中声明的方法,则改写,直接返回调用结果.
                    if (method.getDeclaringClass() == Object.class) {
                        return method.invoke(this, args);
                    }
                    if (platform.isDefaultMethod(method)) {
                        return platform.invokeDefaultMethod(method, service, proxy, args);
                    }
                    return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);
                }
            });
    }
    
    retrofit-2.7.1-sources.jar!\retrofit2\Platform.java
    boolean isDefaultMethod(Method method) {
        return hasJava8Types && method.isDefault();
    }
    
    Sdk\sources\android-29\java\lang\reflect\Method.java
    public boolean isDefault() {
        // Android-changed: isDefault() implemented using Executable.
        return super.isDefaultMethodInternal();
    }
    ```
