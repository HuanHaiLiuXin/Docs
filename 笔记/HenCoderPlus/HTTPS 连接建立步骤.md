## HTTPS 连接建立步骤

#### 1. 客户端向服务器发送"Client Hello",包含以下内容:
- 客户端可以接受的 所有的SSL/TLS的版本
- 客户端可以接受的 所有的 非对称加密算法+对称加密算法+hash算法组合.每个组合称为1个Cipher Suite(密钥算法套件).
- 客户端随机数
- Server name:告知服务器要下发到哪个子服务器
#### 2. 服务器收到客户端发来的"Client Hello"后,选出要使用的SSL/TLS版本+Cipher Suite,再加上服务器随机数,再一起发给客户端:"Server Hello"
- 保存客户端随机数
- 从客户端提供的所有 SSL/TLS版本 中选出要使用的版本
- 从客户端提供的所有 Cipher Suite 中选出要使用的 Cipher Suite
- 然后将选好的 SSL/TLS版本+Cipher Suite,再加上服务器随机数,一起发给客户端:"Server Hello"
- **选好的 SSL/TLS版本+Cipher Suite+客户端随机数+服务器随机数,服务器和客户端一人一份**
#### 3. 服务器向客户端发送 服务器证书,若客户端对服务器证书的验证通过,则客户端对服务器的信任建立成功
**服务器证书结构:**
<br/>
1.证书本身信息(绿色部分)
<br/>
2.证书签发机构信息(橙色部分)
<br/>
**3.证书签发机构的签发机构信息(蓝色部分):签发机构的签发机构,就存在我们电脑/手机根证书列表里,对于设备上存在的根证书,我们只能必须信任**
<br/>
![服务器证书结构](https://github.com/HuanHaiLiuXin/Docs/blob/master/%E5%9B%BE%E7%A4%BA/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%81%E4%B9%A6%E7%BB%93%E6%9E%84.png)
<br/>
**客户端对服务器证书进行验证:满足2个条件,则服务器证书验证通过:**<br/>
**1.确保是证书签发机构对服务器证书进行了签名**
<br/>
**2.确保证书签发机构是可信的**
- *首先要了解 服务器证书中证书签名来源:*
  - 首先把 证书信息,证书公钥,证书签名算法这3个信息揉在一起, 做1个hash,得到原始值OriStr.具体什么hash算法在 证书签名算法里面有.
  - 证书签名算法中包含:具体hash算法,签名用那种非对称加密算法
  - 然后用证书签发机构的私钥对OriStr进行加密运算,得到最终的 证书签名
- *客户端怎么验证证书合法:*
  - 客户端把 证书信息,证书公钥,证书签名算法通过 证书签名算法中的hash算法得出 hash值 ClientHash
  - 用证书签发机构的公钥对 证书签名进行hash,得到 ServerHash
  - 如果 ClientHash和ServerHash相等,就说明的确是证书签发机构对证书进行了签名(只有用 证书签发机构的私钥 加密,公钥解密,才可能ServerHash=ClientHash)
  - *如何验证 证书签发机构 是可信的:用设备上存在的 签发机构的签发机构 来验证签发机构是否可信*
    - 对设备上存在的 签发机构的签发机构,我们只能信任
    - 验证流程和验证证书签名是一致的:
      - 客户端把 签发机构基本信息,签发机构公钥,签发机构签名算法通过 签发机构签名算法中的hash算法得出 hash值 Hash1
      - 客户端用 签发机构的签发机构的公钥 对 签发机构签名进行hash,得到 Hash2
      - 如果 Hash1=Hash2,说明证书签发机构也是可信的
#### 4. Pre-master Secret
- 客户端自己算出1个Pre-master Secret,保存之,并将Pre-master Secret使用服务器公钥加密后发送给服务器,服务器解密后保存Pre-master Secret.两边一人一份
- 客户端和服务器利用两边同样的 客户端随机数+服务器随机数+Pre-master Secret,用固定算法计算出 Master Secret
- 所有的客户端和服务器沟通,都是用同样的算法计算出Master Secret
- Master Secret得到后,客户端随机数+服务器随机数+Pre-master Secret就没用了,客户端和服务器都保存Master Secret
- 客户端和服务器用Master Secret计算出:
  - 真正加密通讯时使用的2个对称加密秘钥
    - 客户端给服务器发消息使用的对称加密密钥M1:客户端密钥
    - 服务器给客户端发消息使用的对称加密秘钥M2:服务器密钥
  - 客户端给服务器,以及服务器给客户端发送消息时用来做HMAC算法的MAC Secret
    - 客户端MAC Secret
    - 服务器MAC Secret
#### 5. 客户端向服务器发送一条通知:将使用加密通信
#### 6. 客户端向服务器发送:Finished
> HMAC:就是1个hash算法,但会在hash里面加上1个Secret(客户端MAC Secret/服务器MAC Secret)
```
原始消息:"111111111111111"
普通hash算法后:"aaaaaaaa"
HMAC:"aabbccdd"
```
只有发送方发送消息时使用的MAC Secret和接收方验证时使用的一致,对同样原始消息进行HMAC摘要运算才能得到相同的HMAC结果.而MAC Secret存在是双方私有的不会被截获,因而可以验证通信对方是否可信.
<br/>
**Finished包含几步:**
  1. 将(1-5)包含之前所有的握手消息,使用客户端MAC Secret进行HMAC,得到S1
  2. 对S1使用客户端密钥进行加密得到S-Client,发送给服务器
  3. 服务器对收到的S-Client,使用客户端密钥得到S11
  4. 服务器将(1-5)包含所有的握手消息,使用客户端MAC Secret进行HMAC,得到S21.如果S11和S21一致,说明消息就是客户端发来的,可信.
#### 7. 服务器向客户端发送一条通知:我也将使用加密通信
#### 8. 服务器向客户端发送:Finished,包含2部分内容
服务器发送的Finished:不仅是对1-7所有握手消息 使用服务器MAC Secret执行HMAC+服务端密钥加密,
<br/>
还包括对6(客户端发送的Finished消息)的解密结果.
<br/>
这样客户端收到服务器发送的Finished消息,就可以明确两边加密通信机制是完全可信的.
