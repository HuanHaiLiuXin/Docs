## 笔记内容来源
1. [胡凯](http://hukai.me/android-performance-patterns/)
2. [anly_jun](https://juejin.im/post/581f4ad667f3560058a33057)
3. [Carson_Ho](https://www.jianshu.com/p/516effe7649d)

## 1.Android性能优化之渲染篇
#### 1.VSYNC
1. 帧率:GPU在1秒内绘制操作的帧数.如60fps.
    - 我们通常都会提到60fps与16ms,这是因为人眼与大脑之间的协作无法感知超过60fps的画面更新.
    - 开发app的性能目标就是保持60fps,这意味着每一帧只有16ms=1000/60的时间来处理所有的任务
2. 刷新率:屏幕在1秒内刷新屏幕的次数.如60Hz,每16ms刷新1次屏幕.
3. GPU获取图形数据进行渲染,然后屏幕将渲染后的内容展示在屏幕上.
4. 大多数手机屏幕的刷新率是60Hz,如果GPU渲染1帧的时间低于1000/60=16ms,那么在屏幕刷新时候都有最新帧可显示.如果GPU渲染某1帧 f 的时间超过16ms,在屏幕刷新时候,f并没有被GPU渲染完成则无法展示,屏幕只能继续展示f的上1帧的内容.这就是掉帧,造成了UI界面的卡顿.
<br>
下面展示了帧率正常和帧率低于刷新率(掉帧)的情形

![](https://user-gold-cdn.xitu.io/2018/9/13/165d0b8f11f18a4f?w=485&h=214&f=png&s=57482)

![](https://user-gold-cdn.xitu.io/2018/9/13/165d0b97070dc3fc?w=482&h=341&f=png&s=59978)

#### 2.GPU渲染:GPU渲染依赖2个组件:CPU和GPU

![](https://user-gold-cdn.xitu.io/2018/9/13/165d0e1008dc510e?w=395&h=262&f=png&s=78502)

![](https://user-gold-cdn.xitu.io/2018/9/13/165d0e172470697a?w=378&h=432&f=png&s=89053)

1. CPU负责Measure,Layout,Record,Execute操作.
2. GPU负责Rasterization(栅格化)操作.
    - Resterization栅格化是绘制那些Button，Shape，Path，String，Bitmap等组件最基础的操作.它把组件拆分到不同的像素上进行显示.这是一个很费时的操作.
    - CPU负责把UI组件计算成Polygons(多边形),Texture(纹理),然后交给GPU进行栅格化渲染.
3. 为了App流畅,我们需要确保在16ms内完成所有CPU和GPU的工作.

#### 3.过度绘制
> Overdraw过度绘制是指屏幕上的某个像素在同一帧的时间内被绘制了多次.过度绘制会大量浪费CPU及GPU资源/占用CPU和GPU的处理时间
- 过度绘制的原因
    1. UI布局存在大量重叠
    2. 非必须的背景重叠.
        - 如Activity有背景,Layout又有背景,子View又有背景.仅仅移除非必要背景就可以显著提升性能.
    3. 子View在onDraw中存在重叠部分绘制的情况,比如Bitmap重叠绘制

#### 4.如何提升渲染性能
1. 移除XML布局文件中非必要的Background
2. 保持布局扁平化,尽量避免布局嵌套
3. 在任何时候都避免调用requestLayout(),调用requestLayout会导致该layout的所有父节点都发生重新layout的操作
4. 在自定义View的onDraw中避免过度绘制.
<br>代码实例:
```java
public class OverdrawView extends View {
    public OverdrawView(Context context) {
        super(context);
        init();
    }

    public OverdrawView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        init();
    }

    public OverdrawView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        init();
    }

    private Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);
    private Bitmap bitmap1,bitmap2,bitmap3;
    private void init(){
        paint.setStyle(Paint.Style.FILL);
        bitmap1 = BitmapFactory.decodeResource(getResources(),R.mipmap.png1);
        bitmap2 = BitmapFactory.decodeResource(getResources(),R.mipmap.png2);
        bitmap3 = BitmapFactory.decodeResource(getResources(),R.mipmap.png3);
    }

    int w,h;
    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        w = getMeasuredWidth();
        h = getMeasuredHeight();
    }

    private boolean Overdraw = true;
    @Override
    protected void onDraw(Canvas canvas) {
        if(Overdraw){
            //默认会出现过度绘制
            canvas.drawBitmap(bitmap1,0,0,paint);
            canvas.drawBitmap(bitmap2,w/3,0,paint);
            canvas.drawBitmap(bitmap3,w*2/3,0,paint);
        }else{
            //使用Canvas.clipRect避免过度绘制
            canvas.save();
            canvas.clipRect(0,0,w/3,h);
            canvas.drawBitmap(bitmap1,0,0,paint);
            canvas.restore();
            canvas.save();
            canvas.clipRect(w/3,0,w*2/3,h);
            canvas.drawBitmap(bitmap2,w/3,0,paint);
            canvas.restore();
            canvas.save();
            canvas.clipRect(w*2/3,0,w,h);
            canvas.drawBitmap(bitmap3,w*2/3,0,paint);
            canvas.restore();
        }
    }
    //切换是否避免过度绘制
    public void toggleOverdraw(){
        Overdraw = !Overdraw;
        invalidate();
    }
}
```
<br>效果图:

![过度绘制](https://user-gold-cdn.xitu.io/2018/9/13/165d1a2e0a6240a8?w=540&h=250&f=png&s=47788)

![避免过度绘制](https://user-gold-cdn.xitu.io/2018/9/13/165d1a31eb7a87e4?w=539&h=250&f=png&s=46659)

## 2.Android性能优化之内存篇
#### 1.Android虚拟机的 分代堆内存/Generational Heap Memory模型

![](https://user-gold-cdn.xitu.io/2018/9/13/165d215aa0bf00ea?w=424&h=318&f=png&s=73573)

![](https://user-gold-cdn.xitu.io/2018/9/13/165d215ca8791693?w=426&h=261&f=png&s=52348)

1. 和JVM不同:Android的堆内存多了1个永久代/Permanent Generation.
2. 和JVM类似:
    1. 新创建的对象存储在新生代/Young Generation
    2. GC所占用的时间和它是哪一个Generation有关,Young Generation的每次GC操作时间是最短的,Old Generation其次,Permanent Generation最长
    3. 无论哪一代,触发GC后,所有非垃圾回收线程暂停,GC结束后所有线程恢复执行
3. 如果短时间内进行过多GC,多次暂停线程进行垃圾回收的累积时间就会增大.占用过多的帧间隔时间/16ms,导致CPU和GPU用于计算渲染的时间不足,导致卡顿/掉帧.

#### 2.内存泄漏和内存溢出
内存泄漏就是无用对象占据的内存空间没有及时释放,导致内存空间浪费的情况.memory leak.
<br>
内存溢出是App为1个对象申请内存空间,内存空间不足的情况.out of memory.
<br>
内存泄漏数量足够大,就会引起内存溢出.或者说内存泄漏是内存溢出的原因之一.


## 3.Android性能优化典范-第2季
#### 1.提升动画性能
1. Bitmap的缩放,旋转,裁剪比较耗性能.例如在一个圆形的钟表图上,我们把时钟的指针抠出来当做单独的图片进行旋转会比旋转一张完整的圆形图性能好.
![](https://user-gold-cdn.xitu.io/2018/9/14/165d76d0bedff35f?w=373&h=173&f=jpeg&s=15468)
2. 尽量减少每次重绘的元素可以极大提升性能.可以把复杂的View拆分会更小的View进行组合,在需要刷新界面时候仅对指定View进行重绘.
    - 假如钟表界面上有很多组件,可以把这些组件做拆分,背景图片单独拎出来设置为一个独立的View,通过setLayerType()方法使得这个View强制用Hardware来进行渲染.至于界面上哪些元素需要做拆分,他们各自的更新频率是多少,需要有针对性的单独讨论
#### 2.对象池
1. 短时间内大量对象被创建然后很快被销毁,会多次触发Android虚拟机在Young generation进行GC,使用AS查看内存曲线,会看到内存曲线剧烈起伏,称为"内存抖动".
2. GC会暂停其他线程,短时间多次GC/内存抖动会引起CPU和GPU在16ms内无法完成当前帧的渲染,引起界面卡顿.
3. 避免内存抖动,可以使用对象池
    - 对象池的作用:减少频繁创建和销毁对象带来的成本,实现对象的缓存和复用
    - [1](https://droidyue.com/blog/2016/12/12/dive-into-object-pool/)
[2](https://www.jianshu.com/p/b981bb758d43)
[3](https://blog.csdn.net/self_study/article/details/51477002) [4](https://blog.csdn.net/zuochunsheng/article/details/54980997)
4. 实例
    ```java
    
    public class User {
        public String id;
        public String name;
        //对象池实例
        private static final SynchronizedPool<User> sPool = new SynchronizedPool<User>(10);
    
        public static User obtain() {
            User instance = sPool.acquire();
            return (instance != null) ? instance : new User();
        }
        public void recycle() {
            sPool.release(this);
        }
    }
    ```

#### 3.for index,for simple,iterator三种遍历性能比较
```java
public class ForTest {
    public static void main(String[] args) {
        Vector<Integer> v = new Vector<>();
        ArrayList<Integer> a = new ArrayList<>();
        LinkedList<Integer> l = new LinkedList<>();
        int time = 1000000;
        for(int i = 0; i< time; i++){
            Integer item = new Random().nextInt(time);
            v.add(item);
            a.add(item);
            l.add(item);
        }
        //测试3种遍历性能
        long start = System.currentTimeMillis();
        for(int i = 0;i<v.size();i++){
            Integer item = v.get(i);
        }
        long end = System.currentTimeMillis();
        System.out.println("for index Vector耗时:"+(end-start)+"ms");
        start = System.currentTimeMillis();
        for(int i = 0;i<a.size();i++){
            Integer item = a.get(i);
        }
        end = System.currentTimeMillis();
        System.out.println("for index ArrayList耗时:"+(end-start)+"ms");
        start = System.currentTimeMillis();
        for(int i = 0;i<l.size();i++){
            Integer item = l.get(i);
        }
        end = System.currentTimeMillis();
        System.out.println("for index LinkedList耗时:"+(end-start)+"ms");
        start = System.currentTimeMillis();
        for(Integer item:v){
            Integer i = item;
        }
        end = System.currentTimeMillis();
        System.out.println("for simple Vector耗时:"+(end-start)+"ms");
        start = System.currentTimeMillis();
        for(Integer item:a){
            Integer i = item;
        }
        end = System.currentTimeMillis();
        System.out.println("for simple ArrayList耗时:"+(end-start)+"ms");
        start = System.currentTimeMillis();
        for(Integer item:l){
            Integer i = item;
        }
        end = System.currentTimeMillis();
        System.out.println("for simple LinkedList耗时:"+(end-start)+"ms");
        start = System.currentTimeMillis();
        for(Iterator i = v.iterator();i.hasNext();){
            Integer item = (Integer) i.next();
        }
        end = System.currentTimeMillis();
        System.out.println("for Iterator Vector耗时:"+(end-start)+"ms");
        start = System.currentTimeMillis();
        for(Iterator i = a.iterator();i.hasNext();){
            Integer item = (Integer) i.next();
        }
        end = System.currentTimeMillis();
        System.out.println("for Iterator ArrayList耗时:"+(end-start)+"ms");
        start = System.currentTimeMillis();
        for(Iterator i = l.iterator();i.hasNext();){
            Integer item = (Integer) i.next();
        }
        end = System.currentTimeMillis();
        System.out.println("for Iterator LinkedList耗时:"+(end-start)+"ms");
    }
}

打印结果:
for index Vector耗时:28ms
for index ArrayList耗时:14ms
LinkedList就不能用for index方式进行遍历.
for simple Vector耗时:68ms
for simple ArrayList耗时:11ms
for simple LinkedList耗时:34ms
for Iterator Vector耗时:49ms
for Iterator ArrayList耗时:12ms
for Iterator LinkedList耗时:0ms
```
1. 不要用for index去遍历链表,因为LinkedList在get任何一个位置的数据的时候,都会把前面的数据走一遍.应该使用Iterator去遍历
    1. get(0),直接拿到0位的Node0的地址,拿到Node0里面的数据
    2. get(1),直接拿到0位的Node0的地址,从0位的Node0中找到下一个1位的Node1的地址,找到Node1,拿到Node1里面的数据
    3. get(2),直接拿到0位的Node0的地址,从0位的Node0中找到下一个1位的Node1的地址,找到Node1,从1位的Node1中找到下一个2位的Node2的地址,找到Node2,拿到Node2里面的数据
2. Vector和ArrayList,使用for index遍历效率较高

#### 4.Merge:通过Merge减少1个View层级
1. 可以将merge当做1个ViewGroup v,如果v的类型和v的父控件的类型一致,那么v其实没必要存在,因为白白增加了布局的深度.所以merge使用时必须保证merge中子控件所应该在的ViewGroup类型和merge所在的父控件类型一致.
2. Merge的使用场景有2个:
    1. Activity的布局文件的根布局是FrameLayout,则将FrameLayout替换为merge
        - 因为setContentView本质就是将布局文件inflate后加载到了id为android.id.content的FrameLayout上.
    2. merge作为根布局的布局文件通过include标签被引入其他布局文件中.这时候include所在的父控件,必须和merge所在的布局文件"原本根布局"一致.
3. 代码示例<br>
merge作为根布局的布局文件,用于Activity的setContentView:
    ```xml
    activity_merge.xml
    
    <?xml version="1.0" encoding="utf-8"?>
    <merge xmlns:android="http://schemas.android.com/apk/res/android"
        android:layout_width="match_parent"
        android:layout_height="match_parent">
        <Button
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="0dp"
            android:text="111111"
            />
        <Button
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginTop="100dp"
            android:layout_marginLeft="40dp"
            android:text="222222"
            />
    </merge>
    ```
    <br>
    merge作为根布局的布局文件,被include标签引入其他布局文件中:
    
    ```xml
    activity_merge_include.xml
    
    <?xml version="1.0" encoding="utf-8"?>
    <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
        android:orientation="vertical" android:layout_width="match_parent"
        android:layout_height="match_parent">
        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="merge被include引用"
            />
        <include
            layout="@layout/activity_merge"
            />
    </LinearLayout>
    ```

#### 5.使用.9.png作为背景
- 典型场景是1个ImageView需要添加1个背景图作为边框.这样边框所在矩形的中间部分和实际显示的图片就好重叠发生Overdraw.
- 可以将背景图制作成.9.png.和前景图重叠部分设置为透明.Android的2D渲染器会优化.9.png的透明区域.

#### 6.减少透明区域对性能的影响
- 不透明的View,显示它只需要渲染一次;如果View设置了alpha值,会至少需要渲染两次,性能不好
    - 设置透明度setAlpha的时候,会把当前view绘制到offscreen buffer中,然后再显示出来.offscreen buffer是 一个临时缓冲区,把View放进来并做透明度的转化,然后显示到屏幕上,这个过程性能差,所以应该尽量避免这个过程
- 如何避免使用offscreen buffer
    1. 对于不存在过度绘制的View,如没有背景的TextView,就可以直接设置文字颜色;ImageView设置图片透明度setImageAlpha;自定义View设置绘制时的paint的透明度
    2. 如果是自定义View,确定不存在过度绘制,可以重写hasOverlappingRendering返回false即可.这样设置alpha时android会自动优化,避免使用offscreen buffer.
        ```java
        @Override
        public boolean hasOverlappingRendering() {
            return false;
        }
        ```
    3. 如果不是1,2两种情况,要设置View的透明度,则需要让GPU来渲染指定View,然后再设置透明度.
        ```java
        View v = findViewById(R.id.root);
        //通过setLayerType的方法来指定View应该如何进行渲染
        //开启硬件加速
        v.setLayerType(View.LAYER_TYPE_HARDWARE,null);
        v.setAlpha(0.60F);
        //透明度设置完毕后关闭硬件加速
        v.setLayerType(View.LAYER_TYPE_NONE,null);
        ```

## 4.Android性能优化典范-第3季
#### 1.避免使用枚举,用注解进行替代
1. 枚举的问题
    1. 每个枚举值都是1个对象,相比较Integer和String常量,枚举的内存开销至少是其2倍.
    2. 过多枚举会增加dex大小及其中的方法数量,增加App占用的空间及引发65536几率
2. 如何替代枚举:使用注解
    1. android.support.annotation中的@IntDef,@StringDef来包装Integer和String常量.
    2. 3个步骤
        1. 首先定义常量
        2. 然后自定义注解,设置取值范围就是刚刚定义的常量,并设置自定义注解的保留范围为源码时/SOURCE
        3. 位指定的属性及方法添加自定义注解.
    3. 代码实例
        ```java
        public class MainActivity extends Activity {
            //1:首先定义常量
            public static final int MALE = 0;
            public static final int FEMALE = 1;
            
            @Override
            protected void onCreate(Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                setContentView(R.layout.main_activity);
                Person person = new Person();
                person.setSex(MALE);
                ((Button) findViewById(R.id.test)).setText(person.getSexDes());
            }
            class Person {
                //3.为指定的属性及方法添加自定义注解
                @SEX
                private int sex;
                //3.为指定的属性及方法添加自定义注解
                public void setSex(@SEX int sex) {
                    this.sex = sex;
                }
                //3.为指定的属性及方法添加自定义注解
                @SEX
                public int getSex() {
                    return sex;
                }
                public String getSexDes() {
                    if (sex == MALE) {
                        return "男";
                    } else {
                        return "女";
                    }
                }
            }
            //2:然后创建自定义注解,设置取值范围就是刚刚定义的常量,并设置自定义注解的保留范围是源码时
            @IntDef({MALE, FEMALE})
            @Retention(RetentionPolicy.SOURCE)
            public @interface SEX {
            }
        }
        ```

## 5.Android内存优化之OOM
#### 如何避免OOM:
1. 减小对象的内存占用
2. 内存对象复用防止重建
3. 避免内存泄漏
4. 内存使用策略优化
#### 1.减小对象的内存占用
1. 避免使用枚举,用注解替代
2. 减小创建的Bitmap的内存,使用合适的缩放比例及解码格式
    1. inSampleSize:缩放比例
    2. decode format:解码格式
#### 2.内存对象的重复利用
1. 对象池技术:减少频繁创建和销毁对象带来的成本,实现对象的缓存和复用
2. 尽量使用Android系统内置资源,可降低APK大小,在一定程度降低内存开销
3. ConvertView的复用
4. LRU的机制实现Bitmap的缓存(图片加载框架的必备机制)
5. 在for循环中,用StringBuilder代替String实现字符串拼接
#### 3.避免内存泄漏
1. 在App中使用leakcanary检测内存泄漏:[leakcanary](https://github.com/square/leakcanary)
2. Activity的内存泄漏
    1. Handler引起Activity内存泄漏
        1. 原因:Handler作为Activity的1个非静态内部类实例,持有Activity实例的引用.若Activity退出后Handler依然有待接收的Message,这时候发生GC,Message-Handler-Activity的引用链导致Activity无法被回收.
        2. 2种解决方法
            1. 在onDestroy调用Handler.removeCallbacksAndMessages(null)移除该Handler关联的所有Message及Runnable.再发生GC,Message已经不存在,就可以顺利的回收Handler及Activity
                ```java
                @Override
                protected void onDestroy() {
                    super.onDestroy();
                    m.removeCallbacksAndMessages(null);
                }
                ```
            2. 自定义静态内部类继承Handler,静态内部类实例不持有外部Activity的引用.在自定义Handler中定义外部Activity的弱引用,只有弱引用关联的外部Activity实例未被回收的情况下才继续执行handleMessage.自定义Handler持有外部Activity的弱引用,发生GC时不耽误Activity被回收.
                ```java
                    static class M extends Handler{
                        WeakReference<Activity> mWeakReference;
                        public M(Activity activity)
                        {
                            mWeakReference=new WeakReference<Activity>(activity);
                        }
                        @Override
                        public void handleMessage(Message msg) {
                            if(mWeakReference != null){
                                Activity activity=mWeakReference.get();
                                if(activity != null){
                                    if(msg.what == 15){
                                        Toast.makeText(activity,"M:15",Toast.LENGTH_SHORT).show();
                                    }
                                    if(msg.what == 5){
                                        Toast.makeText(activity,"M:5",Toast.LENGTH_SHORT).show();
                                    }
                                }
                            }
                        }
                    }
                    private M m;
                    @Override
                    protected void onResume() {
                        super.onResume();
                        m = new M(this);
                        m.sendMessageDelayed(m.obtainMessage(15),15000);
                        m.sendMessageDelayed(m.obtainMessage(5),5000);
                    }
                ```
            
            3. 在避免内存泄漏的前提下,如果要求Activity退出就不执行后续动作,用方法1.如果要求后续动作在GC发生前继续执行,使用方法2
3. Context:尽量使用Application Context而不是Activity Context,避免不经意的内存泄漏
4. 资源对象要及时关闭
#### 4.内存使用策略优化
1. 图片选择合适的文件夹进行存放
    - hdpi/xhdpi/xxhdpi等等不同dpi的文件夹下的图片在不同的设备上会经过scale的处理。例如我们只在hdpi的目录下放置了一张100100的图片，那么根据换算关系，xxhdpi的手机去引用那张图片就会被拉伸到200200。需要注意到在这种情况下，内存占用是会显著提高的。对于不希望被拉伸的图片，需要放到assets或者nodpi的目录下
2. 谨慎使用依赖注入框架.依赖注入框架会扫描代码,需要大量的内存空间映射代码.
3. 混淆可以减少不必要的代码,类,方法等.降低映射代码所需的内存空间
4. onLowMemory()与onTrimMemory():没想到应该怎么用
    1. onLowMemory
        - 当所有的background应用都被kill掉的时候,forground应用会收到onLowMemory()的回调.在这种情况下,需要尽快释放当前应用的非必须的内存资源,从而确保系统能够继续稳定运行
    2. onTrimMemory(int level)
        - 当系统内存达到某些条件的时候,所有正在运行的应用都会收到这个回调,同时在这个回调里面会传递以下的参数,代表不同的内存使用情况,收到onTrimMemory()回调的时候,需要根据传递的参数类型进行判断,合理的选择释放自身的一些内存占用,一方面可以提高系统的整体运行流畅度,另外也可以避免自己被系统判断为优先需要杀掉的应用

## 6.Android开发最佳实践
#### 1.注意对隐式Intent的运行时检查保护
1. 类似打开相机等隐式Intent,不一定能够在所有的Android设备上都正常运行.
    - 例如系统相机应用被关闭或者不存在相机应用,或者某些权限被关闭都可能导致抛出ActivityNotFoundException的异常.
    - 预防这个问题的最佳解决方案是在发出这个隐式Intent之前调用resolveActivity做检查
2. 代码实例
    ```java
    public class IntentCheckActivity extends AppCompatActivity {
        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_intent_check);
        }
        public void openSBTest(View view) {
            // 跳转到"傻逼"软件
            Intent sbIntent = new Intent("android.media.action.IMAGE_GO_SB");
            if (sbIntent.resolveActivity(getPackageManager()) != null) {
                startActivity(sbIntent);
            } else {
                //会弹出这个提示
                Toast.makeText(this,"设备木有傻逼!",Toast.LENGTH_SHORT).show();
            }
        }
        public void openCameraTest(View view) {
            // 跳转到系统照相机
            Intent cameraIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
            if (cameraIntent.resolveActivity(getPackageManager()) != null) {
                startActivity(cameraIntent);
                //正常设备会进入相机并弹出提示
                Toast.makeText(this,"设备有相机!",Toast.LENGTH_LONG).show();
            } else {
                Toast.makeText(this,"设备木有相机!",Toast.LENGTH_SHORT).show();
            }
        }
    }
    ```
#### 2.Android 6.0的权限
#### 3.MD新控件的使用:Toolbar替代ActionBar,AppBarLayout,Navigation Drawer, DrawerLayout, NavigationView等

## 7.Android性能优化典范-第4季
#### 1.网络数据的缓存.okHttp,Picasso都支持网络缓存
[okHttp](https://blog.csdn.net/qq_33463102/article/details/60869879) [Picasso](https://www.cnblogs.com/tonycheng93/p/6381757.html)
#### 2.代码混淆
#### 3.APK瘦身
#### 4.更高效的数据序列化:只是看看从没用过,Protocal Buffers,Nano-Proto-Buffers,FlatBuffers
#### 5.数据呈现的顺序以及结构会对序列化之后的空间产生不小的影响
```java
public final class ZipUtils {

    /**
     * Gzip 压缩数据
     *
     * @param unGzipStr
     * @return
     */
    public static String compressForGzip(String unGzipStr) {

//        if (TextUtils.isEmpty(unGzipStr)) {
//            return null;
//        }
        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            GZIPOutputStream gzip = new GZIPOutputStream(baos);
            gzip.write(unGzipStr.getBytes());
            gzip.close();
            byte[] encode = baos.toByteArray();
            baos.flush();
            baos.close();
//            return Base64Encoder.encode(encode);
            return new String(encode);
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }

        return null;
    }

    /**
     * Gzip解压数据
     *
     * @param gzipStr
     * @return
     */
    public static String decompressForGzip(String gzipStr) {
//        if (TextUtils.isEmpty(gzipStr)) {
//            return null;
//        }
//        byte[] t = Base64Decoder.decodeToBytes(gzipStr);
        byte[] t = gzipStr.getBytes();
        try {
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            ByteArrayInputStream in = new ByteArrayInputStream(t);
            GZIPInputStream gzip = new GZIPInputStream(in);
            byte[] buffer = new byte[1024];
            int n = 0;
            while ((n = gzip.read(buffer, 0, buffer.length)) > 0) {
                out.write(buffer, 0, n);
            }
            gzip.close();
            in.close();
            out.close();
            return out.toString();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
    /**
     * Zip 压缩数据
     *
     * @param unZipStr
     * @return
     */
    public static String compressForZip(String unZipStr) {

//        if (TextUtils.isEmpty(unZipStr)) {
//            return null;
//        }
        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ZipOutputStream zip = new ZipOutputStream(baos);
            zip.putNextEntry(new ZipEntry("0"));
            zip.write(unZipStr.getBytes());
            zip.closeEntry();
            zip.close();
            byte[] encode = baos.toByteArray();
            baos.flush();
            baos.close();
//            return Base64Encoder.encode(encode);
            return new String(encode);
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }

        return null;
    }

    /**
     * Zip解压数据
     *
     * @param zipStr
     * @return
     */
    public static String decompressForZip(String zipStr) {

//        if (TextUtils.isEmpty(zipStr)) {
//            return null;
//        }
//        byte[] t = Base64Decoder.decodeToBytes(zipStr);
        byte[] t = zipStr.getBytes();
        try {
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            ByteArrayInputStream in = new ByteArrayInputStream(t);
            ZipInputStream zip = new ZipInputStream(in);
            zip.getNextEntry();
            byte[] buffer = new byte[1024];
            int n = 0;
            while ((n = zip.read(buffer, 0, buffer.length)) > 0) {
                out.write(buffer, 0, n);
            }
            zip.close();
            in.close();
            out.close();
            return out.toString("UTF-8");
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
}

public class GzipZipTest {
    public static void main(String[] args) {
        GzipZipTest t = new GzipZipTest();
        t.t();
    }
    private void t(){
        /*List<Person> l = new ArrayList<Person>();
        for(int i=0;i<1;i++){
            for(int j=0;j<6000;j++){
                Person p = new Person();
                p.age = j;
                p.gender = "gender"+j;
                p.name = "name"+j;
                l.add(p);
            }
        }
        Gson gson = new Gson();
        List<String> names = new ArrayList<String>();
        List<String> genders = new ArrayList<String>();
        List<Integer> ages = new ArrayList<Integer>();
        for(Person p:l){
            names.add(p.name);
            genders.add(p.gender);
            ages.add(p.age);
        }
        PersonItemList itemList = new PersonItemList();
        itemList.items = l;
        String jsonDataOri = gson.toJson(itemList);
        System.out.println("原始数据结构 压缩前json数据长度 ---->" + jsonDataOri.length());
        PersonAttrList attrList = new PersonAttrList();
        attrList.names = names;
        attrList.genders = genders;
        attrList.ages = ages;
        String jsonDataVariety = gson.toJson(attrList);
        System.out.println("变种数据结构 压缩前json数据长度 ---->" + jsonDataVariety.length());
        System.out.println("===================================================");

        for(int i=0;i<100;i++){
            //1:原始数据结构
            //Gzip压缩
            long start = System.currentTimeMillis();
            String gzipStr = ZipUtils.compressForGzip(jsonDataOri);
            long end = System.currentTimeMillis();
            System.out.println("原始数据结构 Gzip压缩耗时 cost time---->" + (end - start));
            System.out.println("原始数据结构 Gzip压缩后json数据长度 ---->" + gzipStr.length());
            //Zip压缩
//        start = System.currentTimeMillis();
//        String zipStr = ZipUtils.compressForZip(jsonDataOri);
//        end = System.currentTimeMillis();
//        System.out.println("原始数据结构 Zip压缩耗时 cost time---->" + (end - start));
//        System.out.println("原始数据结构 Zip压缩后json数据长度 ---->" + zipStr.length());

            //2:变种数据结构
            //Gzip压缩
            start = System.currentTimeMillis();
            String gzipStrVariety = ZipUtils.compressForGzip(jsonDataVariety);
            end = System.currentTimeMillis();
            System.out.println("变种数据结构 Gzip压缩耗时 cost time---->" + (end - start));
            System.out.println("变种数据结构 Gzip压缩后json数据长度 ---->" + gzipStrVariety.length());
            //Zip压缩
//        start = System.currentTimeMillis();
//        String zipStrVariety = ZipUtils.compressForZip(jsonDataVariety);
//        end = System.currentTimeMillis();
//        System.out.println("变种数据结构 Zip压缩耗时 cost time---->" + (end - start));
//        System.out.println("变种数据结构 Zip压缩后json数据长度 ---->" + zipStrVariety.length());
            System.out.println("压缩后 原始结构长度:变种数据结构="+((float)gzipStr.length())/(float)gzipStrVariety.length());
            System.out.println("===================================================");
        }*/

        float repetitionRatio = 0.00F;
        List<Person> l = new ArrayList<Person>();
        for(repetitionRatio = 0.000F; repetitionRatio < 0.500F; repetitionRatio+=0.005F){
            int reportIndex = (int) (6000 * (1-repetitionRatio));
            for(int i = 0;i<reportIndex;i++){
                Person p = new Person();
                p.age = i;
                p.gender = "gender"+i;
                p.name = "name"+i;
                l.add(p);
            }
            if(repetitionRatio > 0.00F){
                int reportCount = (int) (6000 * repetitionRatio);
                for(int i = 0;i<reportCount;i++){
                    Person p = new Person();
                    p.age = i;
                    p.gender = "gender"+i;
                    p.name = "name"+i;
                    l.add(p);
                }
            }
            Gson gson = new Gson();
            List<String> names = new ArrayList<String>();
            List<String> genders = new ArrayList<String>();
            List<Integer> ages = new ArrayList<Integer>();
            for(Person p:l){
                names.add(p.name);
                genders.add(p.gender);
                ages.add(p.age);
            }
            PersonItemList itemList = new PersonItemList();
            itemList.items = l;
            String jsonDataOri = gson.toJson(itemList);
            System.out.println("===================================================");
            System.out.println("原始数据结构 压缩前json数据长度 ---->" + jsonDataOri.length());
            PersonAttrList attrList = new PersonAttrList();
            attrList.names = names;
            attrList.genders = genders;
            attrList.ages = ages;
            String jsonDataVariety = gson.toJson(attrList);
            System.out.println("变种数据结构 压缩前json数据长度 ---->" + jsonDataVariety.length());
            //1:原始数据结构
            //Gzip压缩
            long start = System.currentTimeMillis();
            String gzipStr = ZipUtils.compressForGzip(jsonDataOri);
            long end = System.currentTimeMillis();
            System.out.println("原始数据结构 Gzip压缩后json数据长度 ---->" + gzipStr.length());

            //2:变种数据结构
            //Gzip压缩
            start = System.currentTimeMillis();
            String gzipStrVariety = ZipUtils.compressForGzip(jsonDataVariety);
            end = System.currentTimeMillis();
            System.out.println("变种数据结构 Gzip压缩后json数据长度 ---->" + gzipStrVariety.length());
            System.out.println("重复率为 "+repetitionRatio/(1-repetitionRatio)+" 压缩后:原始结构长度:变种数据结构="+((float)gzipStr.length())/(float)gzipStrVariety.length());
        }
    }
    public class Person implements Serializable{
        public String name;
        public String gender;
        public int age;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public String getGender() {
            return gender;
        }

        public void setGender(String gender) {
            this.gender = gender;
        }

        public int getAge() {
            return age;
        }

        public void setAge(int age) {
            this.age = age;
        }
    }
    public class PersonItemList implements Serializable{
        public List<Person> items;

        public List<Person> getItems() {
            return items;
        }

        public void setItems(List<Person> items) {
            this.items = items;
        }
    }
    public class PersonAttrList implements Serializable{
        public List<String> names;
        public List<String> genders;
        public List<Integer> ages;

        public List<String> getNames() {
            return names;
        }

        public void setNames(List<String> names) {
            this.names = names;
        }

        public List<String> getGenders() {
            return genders;
        }

        public void setGenders(List<String> genders) {
            this.genders = genders;
        }

        public List<Integer> getAges() {
            return ages;
        }

        public void setAges(List<Integer> ages) {
            this.ages = ages;
        }
    }
}

首先看当单个对象属性重复率超过100%的情况下打印结果:

List<Person> l = new ArrayList<Person>();
        for(int i=0;i<1;i++){
            for(int j=0;j<6000;j++){
                Person p = new Person();
                p.age = j;
                p.gender = "gender"+j;
                p.name = "name"+j;
                l.add(p);
            }
}
原始数据结构 压缩前json数据长度 ---->273011	//因为i和j变动,数据会略有变化
变种数据结构 压缩前json数据长度 ---->129032	//因为i和j变动,数据会略有变化

i=x;	j=y;

//x=1,j=6000:代表数据没有任何重复的情形
x=1;	j=6000;
原始数据结构 Gzip压缩后json数据长度 ---->44215
变种数据结构 Gzip压缩后json数据长度 ---->39561
压缩后 原始结构长度:变种数据结构=1.1176411

//x=2,j=3000:代表每个对象都存在另1个属性完全一致的对象.单个对象重复率100%
x=2;	j=3000;
原始数据结构 Gzip压缩后json数据长度 ---->44204
变种数据结构 Gzip压缩后json数据长度 ---->27628
压缩后 原始结构长度:变种数据结构=1.599971

//余下的代表每单个对象重复率超过100%的情况
x=3;	j=2000;
原始数据结构 Gzip压缩后json数据长度 ---->43733
变种数据结构 Gzip压缩后json数据长度 ---->17020
压缩后 原始结构长度:变种数据结构=2.5695064

x=4;	j=1500;
原始数据结构 Gzip压缩后json数据长度 ---->43398
变种数据结构 Gzip压缩后json数据长度 ---->13914
压缩后 原始结构长度:变种数据结构=3.119017

x=6;	j=1000;
原始数据结构 Gzip压缩后json数据长度 ---->42166
变种数据结构 Gzip压缩后json数据长度 ---->8016
压缩后 原始结构长度:变种数据结构=5.2602296

x=7;	j=857;
原始数据结构 Gzip压缩后json数据长度 ---->41743
变种数据结构 Gzip压缩后json数据长度 ---->7024
压缩后 原始结构长度:变种数据结构=5.94291

x=8;	j=750;
原始数据结构 Gzip压缩后json数据长度 ---->41561
变种数据结构 Gzip压缩后json数据长度 ---->6378
压缩后 原始结构长度:变种数据结构=6.516306

x=9;	j=667;
原始数据结构 Gzip压缩后json数据长度 ---->41491
变种数据结构 Gzip压缩后json数据长度 ---->5870
压缩后 原始结构长度:变种数据结构=7.0683136

x=10;	j=600;
原始数据结构 Gzip压缩后json数据长度 ---->7552
变种数据结构 Gzip压缩后json数据长度 ---->5503
压缩后 原始结构长度:变种数据结构=1.3723423

x=12;	j=500;
原始数据结构 Gzip压缩后json数据长度 ---->6955
变种数据结构 Gzip压缩后json数据长度 ---->4962
压缩后 原始结构长度:变种数据结构=1.4016526

x=15;	j=400;
原始数据结构 Gzip压缩后json数据长度 ---->6207
变种数据结构 Gzip压缩后json数据长度 ---->4179
压缩后 原始结构长度:变种数据结构=1.4852836

x=20;	j=300;
原始数据结构 Gzip压缩后json数据长度 ---->5117
变种数据结构 Gzip压缩后json数据长度 ---->3576
压缩后 原始结构长度:变种数据结构=1.4309285

x=30;	j=200;
原始数据结构 Gzip压缩后json数据长度 ---->4511
变种数据结构 Gzip压缩后json数据长度 ---->3156
压缩后 原始结构长度:变种数据结构=1.429341

x=40;	j=150;
原始数据结构 Gzip压缩后json数据长度 ---->4359
变种数据结构 Gzip压缩后json数据长度 ---->3035
压缩后 原始结构长度:变种数据结构=1.4362438

x=60;	j=100;
原始数据结构 Gzip压缩后json数据长度 ---->2832
变种数据结构 Gzip压缩后json数据长度 ---->1382
压缩后 原始结构长度:变种数据结构=2.049204

x=80;	j=75;
原始数据结构 Gzip压缩后json数据长度 ---->2581
变种数据结构 Gzip压缩后json数据长度 ---->1217
压缩后 原始结构长度:变种数据结构=2.1207888

x=150;	j=40;
原始数据结构 Gzip压缩后json数据长度 ---->1835
变种数据结构 Gzip压缩后json数据长度 ---->890
压缩后 原始结构长度:变种数据结构=2.0617979

x=200;	j=30;
原始数据结构 Gzip压缩后json数据长度 ---->1744
变种数据结构 Gzip压缩后json数据长度 ---->797
压缩后 原始结构长度:变种数据结构=2.1882057

x=300;	j=20;
原始数据结构 Gzip压缩后json数据长度 ---->1539
变种数据结构 Gzip压缩后json数据长度 ---->739
压缩后 原始结构长度:变种数据结构=2.082544

x=316;	j=19;
原始数据结构 Gzip压缩后json数据长度 ---->1269
变种数据结构 Gzip压缩后json数据长度 ---->725
压缩后 原始结构长度:变种数据结构=1.7503449

x=400;	j=15;
原始数据结构 Gzip压缩后json数据长度 ---->1488
变种数据结构 Gzip压缩后json数据长度 ---->662
压缩后 原始结构长度:变种数据结构=2.247734

x=500;	j=12;
原始数据结构 Gzip压缩后json数据长度 ---->1453
变种数据结构 Gzip压缩后json数据长度 ---->563
压缩后 原始结构长度:变种数据结构=2.580817

x=600;	j=10;
原始数据结构 Gzip压缩后json数据长度 ---->1044
变种数据结构 Gzip压缩后json数据长度 ---->573
压缩后 原始结构长度:变种数据结构=1.8219895

x=667;	j=9;
原始数据结构 Gzip压缩后json数据长度 ---->1291
变种数据结构 Gzip压缩后json数据长度 ---->527
压缩后 原始结构长度:变种数据结构=2.4497154

x=750;	j=8;
原始数据结构 Gzip压缩后json数据长度 ---->1155
变种数据结构 Gzip压缩后json数据长度 ---->520
压缩后 原始结构长度:变种数据结构=2.2211537

x=1000;	j=6;
原始数据结构 Gzip压缩后json数据长度 ---->1269
变种数据结构 Gzip压缩后json数据长度 ---->429
压缩后 原始结构长度:变种数据结构=2.958042

x=1200;	j=5;
原始数据结构 Gzip压缩后json数据长度 ---->1135
变种数据结构 Gzip压缩后json数据长度 ---->478
压缩后 原始结构长度:变种数据结构=2.374477

x=3000;	j=2;
原始数据结构 Gzip压缩后json数据长度 ---->990
变种数据结构 Gzip压缩后json数据长度 ---->382
压缩后 原始结构长度:变种数据结构=2.591623

x=6000;	j=1;
原始数据结构 Gzip压缩后json数据长度 ---->590
变种数据结构 Gzip压缩后json数据长度 ---->311
压缩后 原始结构长度:变种数据结构=1.897106

当每个对象属性重复率低于100%的情况下打印结果:
===================================================
原始数据结构 压缩前json数据长度 ---->314681
变种数据结构 压缩前json数据长度 ---->170702
原始数据结构 Gzip压缩后json数据长度 ---->44215
变种数据结构 Gzip压缩后json数据长度 ---->39561
重复率为 0.0 压缩后:原始结构长度:变种数据结构=1.1176411
===================================================
原始数据结构 压缩前json数据长度 ---->629141
变种数据结构 压缩前json数据长度 ---->341162
原始数据结构 Gzip压缩后json数据长度 ---->88279
变种数据结构 Gzip压缩后json数据长度 ---->66875
重复率为 0.0050251256 压缩后:原始结构长度:变种数据结构=1.3200598
===================================================
原始数据结构 压缩前json数据长度 ---->943421
变种数据结构 压缩前json数据长度 ---->511442
原始数据结构 Gzip压缩后json数据长度 ---->131892
变种数据结构 Gzip压缩后json数据长度 ---->90806
重复率为 0.01010101 压缩后:原始结构长度:变种数据结构=1.4524591
===================================================
原始数据结构 压缩前json数据长度 ---->1257521
变种数据结构 压缩前json数据长度 ---->681542
原始数据结构 Gzip压缩后json数据长度 ---->175554
变种数据结构 Gzip压缩后json数据长度 ---->116973
重复率为 0.015228426 压缩后:原始结构长度:变种数据结构=1.5008079
===================================================
原始数据结构 压缩前json数据长度 ---->1571501
变种数据结构 压缩前json数据长度 ---->851522
原始数据结构 Gzip压缩后json数据长度 ---->218945
变种数据结构 Gzip压缩后json数据长度 ---->142129
重复率为 0.020408163 压缩后:原始结构长度:变种数据结构=1.5404668
===================================================
原始数据结构 压缩前json数据长度 ---->1885341
变种数据结构 压缩前json数据长度 ---->1021386
原始数据结构 Gzip压缩后json数据长度 ---->262306
变种数据结构 Gzip压缩后json数据长度 ---->168725
重复率为 0.025641024 压缩后:原始结构长度:变种数据结构=1.5546362
===================================================
原始数据结构 压缩前json数据长度 ---->2199091
变种数据结构 压缩前json数据长度 ---->1191160
原始数据结构 Gzip压缩后json数据长度 ---->305678
变种数据结构 Gzip压缩后json数据长度 ---->191222
重复率为 0.030927831 压缩后:原始结构长度:变种数据结构=1.5985503
===================================================
原始数据结构 压缩前json数据长度 ---->2512751
变种数据结构 压缩前json数据长度 ---->1360844
原始数据结构 Gzip压缩后json数据长度 ---->348774
变种数据结构 Gzip压缩后json数据长度 ---->219050
重复率为 0.036269426 压缩后:原始结构长度:变种数据结构=1.5922118
===================================================
原始数据结构 压缩前json数据长度 ---->2826321
变种数据结构 压缩前json数据长度 ---->1530438
原始数据结构 Gzip压缩后json数据长度 ---->391506
变种数据结构 Gzip压缩后json数据长度 ---->243066
重复率为 0.041666664 压缩后:原始结构长度:变种数据结构=1.6106983
===================================================
原始数据结构 压缩前json数据长度 ---->3139801
变种数据结构 压缩前json数据长度 ---->1699942
原始数据结构 Gzip压缩后json数据长度 ---->434274
变种数据结构 Gzip压缩后json数据长度 ---->268432
重复率为 0.047120415 压缩后:原始结构长度:变种数据结构=1.6178175
===================================================
原始数据结构 压缩前json数据长度 ---->3453191
变种数据结构 压缩前json数据长度 ---->1869356
原始数据结构 Gzip压缩后json数据长度 ---->476356
变种数据结构 Gzip压缩后json数据长度 ---->291550
重复率为 0.052631572 压缩后:原始结构长度:变种数据结构=1.6338742
===================================================
原始数据结构 压缩前json数据长度 ---->3766491
变种数据结构 压缩前json数据长度 ---->2038680
原始数据结构 Gzip压缩后json数据长度 ---->518371
变种数据结构 Gzip压缩后json数据长度 ---->317122
重复率为 0.058201052 压缩后:原始结构长度:变种数据结构=1.6346107
===================================================
原始数据结构 压缩前json数据长度 ---->4079701
变种数据结构 压缩前json数据长度 ---->2207914
原始数据结构 Gzip压缩后json数据长度 ---->560526
变种数据结构 Gzip压缩后json数据长度 ---->344023
重复率为 0.06382978 压缩后:原始结构长度:变种数据结构=1.629327
===================================================
原始数据结构 压缩前json数据长度 ---->4392821
变种数据结构 压缩前json数据长度 ---->2377058
原始数据结构 Gzip压缩后json数据长度 ---->602208
变种数据结构 Gzip压缩后json数据长度 ---->365983
重复率为 0.06951871 压缩后:原始结构长度:变种数据结构=1.6454535
===================================================
原始数据结构 压缩前json数据长度 ---->4705851
变种数据结构 压缩前json数据长度 ---->2546112
原始数据结构 Gzip压缩后json数据长度 ---->643532
变种数据结构 Gzip压缩后json数据长度 ---->391465
重复率为 0.07526881 压缩后:原始结构长度:变种数据结构=1.6439068
===================================================
原始数据结构 压缩前json数据长度 ---->5018791
变种数据结构 压缩前json数据长度 ---->2715076
原始数据结构 Gzip压缩后json数据长度 ---->684775
变种数据结构 Gzip压缩后json数据长度 ---->415902
重复率为 0.08108108 压缩后:原始结构长度:变种数据结构=1.6464816
===================================================
原始数据结构 压缩前json数据长度 ---->5331691
变种数据结构 压缩前json数据长度 ---->2883976
原始数据结构 Gzip压缩后json数据长度 ---->725952
变种数据结构 Gzip压缩后json数据长度 ---->438987
重复率为 0.086956516 压缩后:原始结构长度:变种数据结构=1.6536982
===================================================
原始数据结构 压缩前json数据长度 ---->5644501
变种数据结构 压缩前json数据长度 ---->3052786
原始数据结构 Gzip压缩后json数据长度 ---->767578
变种数据结构 Gzip压缩后json数据长度 ---->464169
重复率为 0.09289617 压缩后:原始结构长度:变种数据结构=1.6536607
===================================================
原始数据结构 压缩前json数据长度 ---->5957221
变种数据结构 压缩前json数据长度 ---->3221506
原始数据结构 Gzip压缩后json数据长度 ---->808616
变种数据结构 Gzip压缩后json数据长度 ---->488167
重复率为 0.09890111 压缩后:原始结构长度:变种数据结构=1.6564331
===================================================
原始数据结构 压缩前json数据长度 ---->6269851
变种数据结构 压缩前json数据长度 ---->3390136
原始数据结构 Gzip压缩后json数据长度 ---->848776
变种数据结构 Gzip压缩后json数据长度 ---->511159
重复率为 0.104972385 压缩后:原始结构长度:变种数据结构=1.6604931
===================================================
原始数据结构 压缩前json数据长度 ---->6582391
变种数据结构 压缩前json数据长度 ---->3558676
原始数据结构 Gzip压缩后json数据长度 ---->889184
变种数据结构 Gzip压缩后json数据长度 ---->536695
重复率为 0.11111113 压缩后:原始结构长度:变种数据结构=1.6567771
===================================================
原始数据结构 压缩前json数据长度 ---->6894841
变种数据结构 压缩前json数据长度 ---->3727126
原始数据结构 Gzip压缩后json数据长度 ---->928982
变种数据结构 Gzip压缩后json数据长度 ---->557274
重复率为 0.11731845 压缩后:原始结构长度:变种数据结构=1.6670111
===================================================
原始数据结构 压缩前json数据长度 ---->7207201
变种数据结构 压缩前json数据长度 ---->3895486
原始数据结构 Gzip压缩后json数据长度 ---->968845
变种数据结构 Gzip压缩后json数据长度 ---->583064
重复率为 0.12359552 压缩后:原始结构长度:变种数据结构=1.6616443
===================================================
原始数据结构 压缩前json数据长度 ---->7519471
变种数据结构 压缩前json数据长度 ---->4063756
原始数据结构 Gzip压缩后json数据长度 ---->1013093
变种数据结构 Gzip压缩后json数据长度 ---->606056
重复率为 0.12994352 压缩后:原始结构长度:变种数据结构=1.6716162
===================================================
原始数据结构 压缩前json数据长度 ---->7831651
变种数据结构 压缩前json数据长度 ---->4231936
原始数据结构 Gzip压缩后json数据长度 ---->1057283
变种数据结构 Gzip压缩后json数据长度 ---->626963
重复率为 0.13636366 压缩后:原始结构长度:变种数据结构=1.6863563
===================================================
原始数据结构 压缩前json数据长度 ---->8143741
变种数据结构 压缩前json数据长度 ---->4400026
原始数据结构 Gzip压缩后json数据长度 ---->1101480
变种数据结构 Gzip压缩后json数据长度 ---->650165
重复率为 0.14285716 压缩后:原始结构长度:变种数据结构=1.6941546
===================================================
原始数据结构 压缩前json数据长度 ---->8455741
变种数据结构 压缩前json数据长度 ---->4568026
原始数据结构 Gzip压缩后json数据长度 ---->1145324
变种数据结构 Gzip压缩后json数据长度 ---->675800
重复率为 0.1494253 压缩后:原始结构长度:变种数据结构=1.6947677
===================================================
原始数据结构 压缩前json数据长度 ---->8767651
变种数据结构 压缩前json数据长度 ---->4735936
原始数据结构 Gzip压缩后json数据长度 ---->1189441
变种数据结构 Gzip压缩后json数据长度 ---->696474
重复率为 0.15606937 压缩后:原始结构长度:变种数据结构=1.7078038
===================================================
原始数据结构 压缩前json数据长度 ---->9079471
变种数据结构 压缩前json数据长度 ---->4903756
原始数据结构 Gzip压缩后json数据长度 ---->1233352
变种数据结构 Gzip压缩后json数据长度 ---->720694
重复率为 0.1627907 压缩后:原始结构长度:变种数据结构=1.7113394
===================================================
原始数据结构 压缩前json数据长度 ---->9391201
变种数据结构 压缩前json数据长度 ---->5071486
原始数据结构 Gzip压缩后json数据长度 ---->1277550
变种数据结构 Gzip压缩后json数据长度 ---->741108
重复率为 0.16959064 压缩后:原始结构长度:变种数据结构=1.7238379
===================================================
原始数据结构 压缩前json数据长度 ---->9702791
变种数据结构 压缩前json数据长度 ---->5239100
原始数据结构 Gzip压缩后json数据长度 ---->1321359
变种数据结构 Gzip压缩后json数据长度 ---->763320
重复率为 0.17647058 压缩后:原始结构长度:变种数据结构=1.7310683
===================================================
原始数据结构 压缩前json数据长度 ---->10014291
变种数据结构 压缩前json数据长度 ---->5406624
原始数据结构 Gzip压缩后json数据长度 ---->1365756
变种数据结构 Gzip压缩后json数据长度 ---->782468
重复率为 0.18343192 压缩后:原始结构长度:变种数据结构=1.7454464
===================================================
原始数据结构 压缩前json数据长度 ---->10325701
变种数据结构 压缩前json数据长度 ---->5574058
原始数据结构 Gzip压缩后json数据长度 ---->1409791
变种数据结构 Gzip压缩后json数据长度 ---->809521
重复率为 0.19047616 压缩后:原始结构长度:变种数据结构=1.7415125
===================================================
原始数据结构 压缩前json数据长度 ---->10637021
变种数据结构 压缩前json数据长度 ---->5741402
原始数据结构 Gzip压缩后json数据长度 ---->1453682
变种数据结构 Gzip压缩后json数据长度 ---->828981
重复率为 0.19760476 压缩后:原始结构长度:变种数据结构=1.753577
===================================================
原始数据结构 压缩前json数据长度 ---->10948308
变种数据结构 压缩前json数据长度 ---->5908713
原始数据结构 Gzip压缩后json数据长度 ---->1497843
变种数据结构 Gzip压缩后json数据长度 ---->852966
重复率为 0.20481923 压缩后:原始结构长度:变种数据结构=1.7560407
===================================================
原始数据结构 压缩前json数据长度 ---->11259595
变种数据结构 压缩前json数据长度 ---->6076024
原始数据结构 Gzip压缩后json数据长度 ---->1542039
变种数据结构 Gzip压缩后json数据长度 ---->872647
重复率为 0.21212116 压缩后:原始结构长度:变种数据结构=1.7670822
===================================================
原始数据结构 压缩前json数据长度 ---->11570882
变种数据结构 压缩前json数据长度 ---->6243335
原始数据结构 Gzip压缩后json数据长度 ---->1585781
变种数据结构 Gzip压缩后json数据长度 ---->891023
重复率为 0.21951213 压缩后:原始结构长度:变种数据结构=1.7797307
===================================================
原始数据结构 压缩前json数据长度 ---->11882169
变种数据结构 压缩前json数据长度 ---->6410646
原始数据结构 Gzip压缩后json数据长度 ---->1629443
变种数据结构 Gzip压缩后json数据长度 ---->915561
重复率为 0.2269938 压缩后:原始结构长度:变种数据结构=1.7797209
===================================================
原始数据结构 压缩前json数据长度 ---->12193456
变种数据结构 压缩前json数据长度 ---->6577957
原始数据结构 Gzip压缩后json数据长度 ---->1673135
变种数据结构 Gzip压缩后json数据长度 ---->937219
重复率为 0.23456782 压缩后:原始结构长度:变种数据结构=1.7852124
===================================================
原始数据结构 压缩前json数据长度 ---->12504743
变种数据结构 压缩前json数据长度 ---->6745268
原始数据结构 Gzip压缩后json数据长度 ---->1717525
变种数据结构 Gzip压缩后json数据长度 ---->956429
重复率为 0.24223594 压缩后:原始结构长度:变种数据结构=1.7957684
===================================================
原始数据结构 压缩前json数据长度 ---->12816030
变种数据结构 压缩前json数据长度 ---->6912579
原始数据结构 Gzip压缩后json数据长度 ---->1761849
变种数据结构 Gzip压缩后json数据长度 ---->976092
重复率为 0.24999991 压缩后:原始结构长度:变种数据结构=1.805003
===================================================
原始数据结构 压缩前json数据长度 ---->13127317
变种数据结构 压缩前json数据长度 ---->7079890
原始数据结构 Gzip压缩后json数据长度 ---->1806001
变种数据结构 Gzip压缩后json数据长度 ---->995442
重复率为 0.25786152 压缩后:原始结构长度:变种数据结构=1.8142705
===================================================
原始数据结构 压缩前json数据长度 ---->13438604
变种数据结构 压缩前json数据长度 ---->7247201
原始数据结构 Gzip压缩后json数据长度 ---->1850241
变种数据结构 Gzip压缩后json数据长度 ---->1014463
重复率为 0.26582268 压缩后:原始结构长度:变种数据结构=1.8238624
===================================================
原始数据结构 压缩前json数据长度 ---->13749891
变种数据结构 压缩前json数据长度 ---->7414512
原始数据结构 Gzip压缩后json数据长度 ---->1893946
变种数据结构 Gzip压缩后json数据长度 ---->1038690
重复率为 0.27388522 压缩后:原始结构长度:变种数据结构=1.8233987
===================================================
原始数据结构 压缩前json数据长度 ---->14061178
变种数据结构 压缩前json数据长度 ---->7581823
原始数据结构 Gzip压缩后json数据长度 ---->1938584
变种数据结构 Gzip压缩后json数据长度 ---->1064229
重复率为 0.28205115 压缩后:原始结构长度:变种数据结构=1.8215854
===================================================
原始数据结构 压缩前json数据长度 ---->14372465
变种数据结构 压缩前json数据长度 ---->7749134
原始数据结构 Gzip压缩后json数据长度 ---->1982416
变种数据结构 Gzip压缩后json数据长度 ---->1079948
重复率为 0.29032245 压缩后:原始结构长度:变种数据结构=1.8356588
===================================================
原始数据结构 压缩前json数据长度 ---->14683752
变种数据结构 压缩前json数据长度 ---->7916445
原始数据结构 Gzip压缩后json数据长度 ---->2026663
变种数据结构 Gzip压缩后json数据长度 ---->1102001
重复率为 0.29870114 压缩后:原始结构长度:变种数据结构=1.8390754
===================================================
原始数据结构 压缩前json数据长度 ---->14995039
变种数据结构 压缩前json数据长度 ---->8083756
原始数据结构 Gzip压缩后json数据长度 ---->2070714
变种数据结构 Gzip压缩后json数据长度 ---->1125712
重复率为 0.30718938 压缩后:原始结构长度:变种数据结构=1.8394705
===================================================
原始数据结构 压缩前json数据长度 ---->15306326
变种数据结构 压缩前json数据长度 ---->8251067
原始数据结构 Gzip压缩后json数据长度 ---->2114297
变种数据结构 Gzip压缩后json数据长度 ---->1145723
重复率为 0.3157893 压缩后:原始结构长度:变种数据结构=1.8453823
===================================================
原始数据结构 压缩前json数据长度 ---->15617613
变种数据结构 压缩前json数据长度 ---->8418378
原始数据结构 Gzip压缩后json数据长度 ---->2158166
变种数据结构 Gzip压缩后json数据长度 ---->1164141
重复率为 0.32450312 压缩后:原始结构长度:变种数据结构=1.8538699
===================================================
原始数据结构 压缩前json数据长度 ---->15928900
变种数据结构 压缩前json数据长度 ---->8585689
原始数据结构 Gzip压缩后json数据长度 ---->2201712
变种数据结构 Gzip压缩后json数据长度 ---->1189557
重复率为 0.33333313 压缩后:原始结构长度:变种数据结构=1.8508672
===================================================
原始数据结构 压缩前json数据长度 ---->16240187
变种数据结构 压缩前json数据长度 ---->8753000
原始数据结构 Gzip压缩后json数据长度 ---->2245653
变种数据结构 Gzip压缩后json数据长度 ---->1207825
重复率为 0.3422817 压缩后:原始结构长度:变种数据结构=1.8592536
===================================================
原始数据结构 压缩前json数据长度 ---->16551474
变种数据结构 压缩前json数据长度 ---->8920311
原始数据结构 Gzip压缩后json数据长度 ---->2289778
变种数据结构 Gzip压缩后json数据长度 ---->1228716
重复率为 0.35135114 压缩后:原始结构长度:变种数据结构=1.8635535
===================================================
原始数据结构 压缩前json数据长度 ---->16862761
变种数据结构 压缩前json数据长度 ---->9087622
原始数据结构 Gzip压缩后json数据长度 ---->2333883
变种数据结构 Gzip压缩后json数据长度 ---->1248197
重复率为 0.36054403 压缩后:原始结构长度:变种数据结构=1.8698034
===================================================
原始数据结构 压缩前json数据长度 ---->17174048
变种数据结构 压缩前json数据长度 ---->9254933
原始数据结构 Gzip压缩后json数据长度 ---->2377734
变种数据结构 Gzip压缩后json数据长度 ---->1263293
重复率为 0.3698628 压缩后:原始结构长度:变种数据结构=1.8821714
===================================================
原始数据结构 压缩前json数据长度 ---->17485335
变种数据结构 压缩前json数据长度 ---->9422244
原始数据结构 Gzip压缩后json数据长度 ---->2421204
变种数据结构 Gzip压缩后json数据长度 ---->1286647
重复率为 0.3793101 压缩后:原始结构长度:变种数据结构=1.8817935
===================================================
原始数据结构 压缩前json数据长度 ---->17796622
变种数据结构 压缩前json数据长度 ---->9589555
原始数据结构 Gzip压缩后json数据长度 ---->2464871
变种数据结构 Gzip压缩后json数据长度 ---->1307479
重复率为 0.38888866 压缩后:原始结构长度:变种数据结构=1.8852088
===================================================
原始数据结构 压缩前json数据长度 ---->18107909
变种数据结构 压缩前json数据长度 ---->9756866
原始数据结构 Gzip压缩后json数据长度 ---->2508873
变种数据结构 Gzip压缩后json数据长度 ---->1327997
重复率为 0.39860114 压缩后:原始结构长度:变种数据结构=1.8892158
===================================================
原始数据结构 压缩前json数据长度 ---->18419196
变种数据结构 压缩前json数据长度 ---->9924177
原始数据结构 Gzip压缩后json数据长度 ---->2552954
变种数据结构 Gzip压缩后json数据长度 ---->1342020
重复率为 0.40845042 压缩后:原始结构长度:变种数据结构=1.9023218
===================================================
原始数据结构 压缩前json数据长度 ---->18730483
变种数据结构 压缩前json数据长度 ---->10091488
原始数据结构 Gzip压缩后json数据长度 ---->2596616
变种数据结构 Gzip压缩后json数据长度 ---->1369092
重复率为 0.41843942 压缩后:原始结构长度:变种数据结构=1.8965971
===================================================
原始数据结构 压缩前json数据长度 ---->19041770
变种数据结构 压缩前json数据长度 ---->10258799
原始数据结构 Gzip压缩后json数据长度 ---->2640984
变种数据结构 Gzip压缩后json数据长度 ---->1383626
重复率为 0.42857113 压缩后:原始结构长度:变种数据结构=1.9087412
===================================================
原始数据结构 压缩前json数据长度 ---->19353057
变种数据结构 压缩前json数据长度 ---->10426110
原始数据结构 Gzip压缩后json数据长度 ---->2685199
变种数据结构 Gzip压缩后json数据长度 ---->1402782
重复率为 0.4388486 压缩后:原始结构长度:变种数据结构=1.9141955
===================================================
原始数据结构 压缩前json数据长度 ---->19664344
变种数据结构 压缩前json数据长度 ---->10593421
原始数据结构 Gzip压缩后json数据长度 ---->2729710
变种数据结构 Gzip压缩后json数据长度 ---->1418750
重复率为 0.44927505 压缩后:原始结构长度:变种数据结构=1.9240247
===================================================
原始数据结构 压缩前json数据长度 ---->19975631
变种数据结构 压缩前json数据长度 ---->10760732
原始数据结构 Gzip压缩后json数据长度 ---->2773735
变种数据结构 Gzip压缩后json数据长度 ---->1435122
重复率为 0.45985368 压缩后:原始结构长度:变种数据结构=1.932752
===================================================
原始数据结构 压缩前json数据长度 ---->20286918
变种数据结构 压缩前json数据长度 ---->10928043
原始数据结构 Gzip压缩后json数据长度 ---->2818175
变种数据结构 Gzip压缩后json数据长度 ---->1458645
重复率为 0.47058788 压缩后:原始结构长度:变种数据结构=1.93205
===================================================
原始数据结构 压缩前json数据长度 ---->20598205
变种数据结构 压缩前json数据长度 ---->11095354
原始数据结构 Gzip压缩后json数据长度 ---->2862715
变种数据结构 Gzip压缩后json数据长度 ---->1473688
重复率为 0.4814811 压缩后:原始结构长度:变种数据结构=1.9425516
===================================================
原始数据结构 压缩前json数据长度 ---->20909492
变种数据结构 压缩前json数据长度 ---->11262665
原始数据结构 Gzip压缩后json数据长度 ---->2906140
变种数据结构 Gzip压缩后json数据长度 ---->1497577
重复率为 0.49253693 压缩后:原始结构长度:变种数据结构=1.9405613
===================================================
原始数据结构 压缩前json数据长度 ---->21220779
变种数据结构 压缩前json数据长度 ---->11429976
原始数据结构 Gzip压缩后json数据长度 ---->2951053
变种数据结构 Gzip压缩后json数据长度 ---->1513485
重复率为 0.50375897 压缩后:原始结构长度:变种数据结构=1.9498396
===================================================
原始数据结构 压缩前json数据长度 ---->21532066
变种数据结构 压缩前json数据长度 ---->11597287
原始数据结构 Gzip压缩后json数据长度 ---->2995263
变种数据结构 Gzip压缩后json数据长度 ---->1528176
重复率为 0.5151511 压缩后:原始结构长度:变种数据结构=1.9600248
===================================================
原始数据结构 压缩前json数据长度 ---->21843353
变种数据结构 压缩前json数据长度 ---->11764598
原始数据结构 Gzip压缩后json数据长度 ---->3039623
变种数据结构 Gzip压缩后json数据长度 ---->1546990
重复率为 0.5267171 压缩后:原始结构长度:变种数据结构=1.9648627
===================================================
原始数据结构 压缩前json数据长度 ---->22154640
变种数据结构 压缩前json数据长度 ---->11931909
原始数据结构 Gzip压缩后json数据长度 ---->3083971
变种数据结构 Gzip压缩后json数据长度 ---->1563906
重复率为 0.5384611 压缩后:原始结构长度:变种数据结构=1.971967
===================================================
原始数据结构 压缩前json数据长度 ---->22465927
变种数据结构 压缩前json数据长度 ---->12099220
原始数据结构 Gzip压缩后json数据长度 ---->3128112
变种数据结构 Gzip压缩后json数据长度 ---->1580792
重复率为 0.55038714 压缩后:原始结构长度:变种数据结构=1.9788258
===================================================
原始数据结构 压缩前json数据长度 ---->22777214
变种数据结构 压缩前json数据长度 ---->12266531
原始数据结构 Gzip压缩后json数据长度 ---->3171693
变种数据结构 Gzip压缩后json数据长度 ---->1600344
重复率为 0.5624995 压缩后:原始结构长度:变种数据结构=1.981882
===================================================
原始数据结构 压缩前json数据长度 ---->23088501
变种数据结构 压缩前json数据长度 ---->12433842
原始数据结构 Gzip压缩后json数据长度 ---->3215617
变种数据结构 Gzip压缩后json数据长度 ---->1618740
重复率为 0.57480264 压缩后:原始结构长度:变种数据结构=1.9864938
===================================================
原始数据结构 压缩前json数据长度 ---->23399788
变种数据结构 压缩前json数据长度 ---->12601153
原始数据结构 Gzip压缩后json数据长度 ---->3259832
变种数据结构 Gzip压缩后json数据长度 ---->1637726
重复率为 0.5873011 压缩后:原始结构长度:变种数据结构=1.9904624
===================================================
原始数据结构 压缩前json数据长度 ---->23711075
变种数据结构 压缩前json数据长度 ---->12768464
原始数据结构 Gzip压缩后json数据长度 ---->3304008
变种数据结构 Gzip压缩后json数据长度 ---->1652686
重复率为 0.5999994 压缩后:原始结构长度:变种数据结构=1.9991747
===================================================
原始数据结构 压缩前json数据长度 ---->24022362
变种数据结构 压缩前json数据长度 ---->12935775
原始数据结构 Gzip压缩后json数据长度 ---->3347657
变种数据结构 Gzip压缩后json数据长度 ---->1670445
重复率为 0.61290264 压缩后:原始结构长度:变种数据结构=2.004051
===================================================
原始数据结构 压缩前json数据长度 ---->24333649
变种数据结构 压缩前json数据长度 ---->13103086
原始数据结构 Gzip压缩后json数据长度 ---->3391716
变种数据结构 Gzip压缩后json数据长度 ---->1683890
重复率为 0.62601566 压缩后:原始结构长度:变种数据结构=2.0142148
===================================================
原始数据结构 压缩前json数据长度 ---->24644936
变种数据结构 压缩前json数据长度 ---->13270397
原始数据结构 Gzip压缩后json数据长度 ---->3436086
变种数据结构 Gzip压缩后json数据长度 ---->1704452
重复率为 0.6393436 压缩后:原始结构长度:变种数据结构=2.0159476
===================================================
原始数据结构 压缩前json数据长度 ---->24956223
变种数据结构 压缩前json数据长度 ---->13437708
原始数据结构 Gzip压缩后json数据长度 ---->3480064
变种数据结构 Gzip压缩后json数据长度 ---->1719727
重复率为 0.65289193 压缩后:原始结构长度:变种数据结构=2.0236142
===================================================
原始数据结构 压缩前json数据长度 ---->25267510
变种数据结构 压缩前json数据长度 ---->13605019
原始数据结构 Gzip压缩后json数据长度 ---->3524494
变种数据结构 Gzip压缩后json数据长度 ---->1735590
重复率为 0.666666 压缩后:原始结构长度:变种数据结构=2.030718
===================================================
原始数据结构 压缩前json数据长度 ---->25578797
变种数据结构 压缩前json数据长度 ---->13772330
原始数据结构 Gzip压缩后json数据长度 ---->3569109
变种数据结构 Gzip压缩后json数据长度 ---->1757409
重复率为 0.6806716 压缩后:原始结构长度:变种数据结构=2.0308926
===================================================
原始数据结构 压缩前json数据长度 ---->25890084
变种数据结构 压缩前json数据长度 ---->13939641
原始数据结构 Gzip压缩后json数据长度 ---->3613919
变种数据结构 Gzip压缩后json数据长度 ---->1770126
重复率为 0.6949145 压缩后:原始结构长度:变种数据结构=2.041617
===================================================
原始数据结构 压缩前json数据长度 ---->26201371
变种数据结构 压缩前json数据长度 ---->14106952
原始数据结构 Gzip压缩后json数据长度 ---->3658034
变种数据结构 Gzip压缩后json数据长度 ---->1787002
重复率为 0.70940095 压缩后:原始结构长度:变种数据结构=2.0470228
===================================================
原始数据结构 压缩前json数据长度 ---->26512658
变种数据结构 压缩前json数据长度 ---->14274263
原始数据结构 Gzip压缩后json数据长度 ---->3702835
变种数据结构 Gzip压缩后json数据长度 ---->1799515
重复率为 0.7241371 压缩后:原始结构长度:变种数据结构=2.057685
===================================================
原始数据结构 压缩前json数据长度 ---->26823945
变种数据结构 压缩前json数据长度 ---->14441574
原始数据结构 Gzip压缩后json数据长度 ---->3746980
变种数据结构 Gzip压缩后json数据长度 ---->1818417
重复率为 0.7391296 压缩后:原始结构长度:变种数据结构=2.0605724
===================================================
原始数据结构 压缩前json数据长度 ---->27135232
变种数据结构 压缩前json数据长度 ---->14608885
原始数据结构 Gzip压缩后json数据长度 ---->3790555
变种数据结构 Gzip压缩后json数据长度 ---->1836003
重复率为 0.7543851 压缩后:原始结构长度:变种数据结构=2.064569
===================================================
原始数据结构 压缩前json数据长度 ---->27446519
变种数据结构 压缩前json数据长度 ---->14776196
原始数据结构 Gzip压缩后json数据长度 ---->3834464
变种数据结构 Gzip压缩后json数据长度 ---->1851563
重复率为 0.76991063 压缩后:原始结构长度:变种数据结构=2.0709336
===================================================
原始数据结构 压缩前json数据长度 ---->27757806
变种数据结构 压缩前json数据长度 ---->14943507
原始数据结构 Gzip压缩后json数据长度 ---->3879072
变种数据结构 Gzip压缩后json数据长度 ---->1873192
重复率为 0.7857134 压缩后:原始结构长度:变种数据结构=2.0708354
===================================================
原始数据结构 压缩前json数据长度 ---->28069093
变种数据结构 压缩前json数据长度 ---->15110818
原始数据结构 Gzip压缩后json数据长度 ---->3923316
变种数据结构 Gzip压缩后json数据长度 ---->1894024
重复率为 0.80180085 压缩后:原始结构长度:变种数据结构=2.0714183
===================================================
原始数据结构 压缩前json数据长度 ---->28380380
变种数据结构 压缩前json数据长度 ---->15278129
原始数据结构 Gzip压缩后json数据长度 ---->3967482
变种数据结构 Gzip压缩后json数据长度 ---->1916387
重复率为 0.81818086 压缩后:原始结构长度:变种数据结构=2.0702927
===================================================
原始数据结构 压缩前json数据长度 ---->28691667
变种数据结构 压缩前json数据长度 ---->15445440
原始数据结构 Gzip压缩后json数据长度 ---->4011094
变种数据结构 Gzip压缩后json数据长度 ---->1933486
重复率为 0.8348614 压缩后:原始结构长度:变种数据结构=2.07454
===================================================
原始数据结构 压缩前json数据长度 ---->29002954
变种数据结构 压缩前json数据长度 ---->15612751
原始数据结构 Gzip压缩后json数据长度 ---->4055289
变种数据结构 Gzip压缩后json数据长度 ---->1953997
重复率为 0.8518508 压缩后:原始结构长度:变种数据结构=2.0753813
===================================================
原始数据结构 压缩前json数据长度 ---->29314241
变种数据结构 压缩前json数据长度 ---->15780062
原始数据结构 Gzip压缩后json数据长度 ---->4099592
变种数据结构 Gzip压缩后json数据长度 ---->1974066
重复率为 0.8691578 压缩后:原始结构长度:变种数据结构=2.076725
===================================================
原始数据结构 压缩前json数据长度 ---->29625528
变种数据结构 压缩前json数据长度 ---->15947373
原始数据结构 Gzip压缩后json数据长度 ---->4143573
变种数据结构 Gzip压缩后json数据长度 ---->1987771
重复率为 0.88679135 压缩后:原始结构长度:变种数据结构=2.0845323
===================================================
原始数据结构 压缩前json数据长度 ---->29936815
变种数据结构 压缩前json数据长度 ---->16114684
原始数据结构 Gzip压缩后json数据长度 ---->4187707
变种数据结构 Gzip压缩后json数据长度 ---->2014350
重复率为 0.9047608 压缩后:原始结构长度:变种数据结构=2.078937
===================================================
原始数据结构 压缩前json数据长度 ---->30248102
变种数据结构 压缩前json数据长度 ---->16281995
原始数据结构 Gzip压缩后json数据长度 ---->4232504
变种数据结构 Gzip压缩后json数据长度 ---->2034384
重复率为 0.92307574 压缩后:原始结构长度:变种数据结构=2.0804844
===================================================
原始数据结构 压缩前json数据长度 ---->30559389
变种数据结构 压缩前json数据长度 ---->16449306
原始数据结构 Gzip压缩后json数据长度 ---->4277046
变种数据结构 Gzip压缩后json数据长度 ---->2053854
重复率为 0.94174635 压缩后:原始结构长度:变种数据结构=2.082449
===================================================
原始数据结构 压缩前json数据长度 ---->30870676
变种数据结构 压缩前json数据长度 ---->16616617
原始数据结构 Gzip压缩后json数据长度 ---->4321134
变种数据结构 Gzip压缩后json数据长度 ---->2072485
重复率为 0.960783 压缩后:原始结构长度:变种数据结构=2.0850012
===================================================
原始数据结构 压缩前json数据长度 ---->31181963
变种数据结构 压缩前json数据长度 ---->16783928
原始数据结构 Gzip压缩后json数据长度 ---->4365924
变种数据结构 Gzip压缩后json数据长度 ---->2087159
重复率为 0.9801967 压缩后:原始结构长度:变种数据结构=2.0918024
===================================================
原始数据结构 压缩前json数据长度 ---->31493250
变种数据结构 压缩前json数据长度 ---->16951239
原始数据结构 Gzip压缩后json数据长度 ---->4409476
变种数据结构 Gzip压缩后json数据长度 ---->2100664
重复率为 0.9999986 压缩后:原始结构长度:变种数据结构=2.0990868

```
