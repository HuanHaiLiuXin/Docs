## 笔记内容来源
1. [胡凯](http://hukai.me/android-performance-patterns/)
2. [anly_jun](https://juejin.im/post/581f4ad667f3560058a33057)
3. [Carson_Ho](https://www.jianshu.com/p/516effe7649d)

## 1.Android性能优化之渲染篇
#### 1.VSYNC
1. 帧率:GPU在1秒内绘制操作的帧数.如60fps.
    - 我们通常都会提到60fps与16ms,这是因为人眼与大脑之间的协作无法感知超过60fps的画面更新.
    - 开发app的性能目标就是保持60fps,这意味着每一帧只有16ms=1000/60的时间来处理所有的任务
2. 刷新率:屏幕在1秒内刷新屏幕的次数.如60Hz,每16ms刷新1次屏幕.
3. GPU获取图形数据进行渲染,然后屏幕将渲染后的内容展示在屏幕上.
4. 大多数手机屏幕的刷新率是60Hz,如果GPU渲染1帧的时间低于1000/60=16ms,那么在屏幕刷新时候都有最新帧可显示.如果GPU渲染某1帧 f 的时间超过16ms,在屏幕刷新时候,f并没有被GPU渲染完成则无法展示,屏幕只能继续展示f的上1帧的内容.这就是掉帧,造成了UI界面的卡顿.
<br>
下面展示了帧率正常和帧率低于刷新率(掉帧)的情形

![](https://user-gold-cdn.xitu.io/2018/9/13/165d0b8f11f18a4f?w=485&h=214&f=png&s=57482)

![](https://user-gold-cdn.xitu.io/2018/9/13/165d0b97070dc3fc?w=482&h=341&f=png&s=59978)

#### 2.GPU渲染:GPU渲染依赖2个组件:CPU和GPU

![](https://user-gold-cdn.xitu.io/2018/9/13/165d0e1008dc510e?w=395&h=262&f=png&s=78502)

![](https://user-gold-cdn.xitu.io/2018/9/13/165d0e172470697a?w=378&h=432&f=png&s=89053)

1. CPU负责Measure,Layout,Record,Execute操作.
2. GPU负责Rasterization(栅格化)操作.
    - Resterization栅格化是绘制那些Button，Shape，Path，String，Bitmap等组件最基础的操作.它把组件拆分到不同的像素上进行显示.这是一个很费时的操作.
    - CPU负责把UI组件计算成Polygons(多边形),Texture(纹理),然后交给GPU进行栅格化渲染.
3. 为了App流畅,我们需要确保在16ms内完成所有CPU和GPU的工作.

#### 3.过度绘制
> Overdraw过度绘制是指屏幕上的某个像素在同一帧的时间内被绘制了多次.过度绘制会大量浪费CPU及GPU资源/占用CPU和GPU的处理时间
- 过度绘制的原因
    1. UI布局存在大量重叠
    2. 非必须的背景重叠.
        - 如Activity有背景,Layout又有背景,子View又有背景.仅仅移除非必要背景就可以显著提升性能.
    3. 子View在onDraw中存在重叠部分绘制的情况,比如Bitmap重叠绘制

#### 4.如何提升渲染性能
1. 移除XML布局文件中非必要的Background
2. 保持布局扁平化,尽量避免布局嵌套
3. 在任何时候都避免调用requestLayout(),调用requestLayout会导致该layout的所有父节点都发生重新layout的操作
4. 在自定义View的onDraw中避免过度绘制.
<br>代码实例:
```java
public class OverdrawView extends View {
    public OverdrawView(Context context) {
        super(context);
        init();
    }

    public OverdrawView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        init();
    }

    public OverdrawView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        init();
    }

    private Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);
    private Bitmap bitmap1,bitmap2,bitmap3;
    private void init(){
        paint.setStyle(Paint.Style.FILL);
        bitmap1 = BitmapFactory.decodeResource(getResources(),R.mipmap.png1);
        bitmap2 = BitmapFactory.decodeResource(getResources(),R.mipmap.png2);
        bitmap3 = BitmapFactory.decodeResource(getResources(),R.mipmap.png3);
    }

    int w,h;
    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        w = getMeasuredWidth();
        h = getMeasuredHeight();
    }

    private boolean Overdraw = true;
    @Override
    protected void onDraw(Canvas canvas) {
        if(Overdraw){
            //默认会出现过度绘制
            canvas.drawBitmap(bitmap1,0,0,paint);
            canvas.drawBitmap(bitmap2,w/3,0,paint);
            canvas.drawBitmap(bitmap3,w*2/3,0,paint);
        }else{
            //使用Canvas.clipRect避免过度绘制
            canvas.save();
            canvas.clipRect(0,0,w/3,h);
            canvas.drawBitmap(bitmap1,0,0,paint);
            canvas.restore();
            canvas.save();
            canvas.clipRect(w/3,0,w*2/3,h);
            canvas.drawBitmap(bitmap2,w/3,0,paint);
            canvas.restore();
            canvas.save();
            canvas.clipRect(w*2/3,0,w,h);
            canvas.drawBitmap(bitmap3,w*2/3,0,paint);
            canvas.restore();
        }
    }
    //切换是否避免过度绘制
    public void toggleOverdraw(){
        Overdraw = !Overdraw;
        invalidate();
    }
}
```
<br>效果图:

![过度绘制](https://user-gold-cdn.xitu.io/2018/9/13/165d1a2e0a6240a8?w=540&h=250&f=png&s=47788)

![避免过度绘制](https://user-gold-cdn.xitu.io/2018/9/13/165d1a31eb7a87e4?w=539&h=250&f=png&s=46659)

## 2.Android性能优化之内存篇
#### 1.Android虚拟机的 分代堆内存/Generational Heap Memory模型

![](https://user-gold-cdn.xitu.io/2018/9/13/165d215aa0bf00ea?w=424&h=318&f=png&s=73573)

![](https://user-gold-cdn.xitu.io/2018/9/13/165d215ca8791693?w=426&h=261&f=png&s=52348)

1. 和JVM不同:Android的堆内存多了1个永久代/Permanent Generation.
2. 和JVM类似:
    1. 新创建的对象存储在新生代/Young Generation
    2. GC所占用的时间和它是哪一个Generation有关,Young Generation的每次GC操作时间是最短的,Old Generation其次,Permanent Generation最长
    3. 无论哪一代,触发GC后,所有非垃圾回收线程暂停,GC结束后所有线程恢复执行
3. 如果短时间内进行过多GC,多次暂停线程进行垃圾回收的累积时间就会增大.占用过多的帧间隔时间/16ms,导致CPU和GPU用于计算渲染的时间不足,导致卡顿/掉帧.

#### 2.内存泄漏和内存溢出
内存泄漏就是无用对象占据的内存空间没有及时释放,导致内存空间浪费的情况.memory leak.
<br>
内存溢出是App为1个对象申请内存空间,内存空间不足的情况.out of memory.
<br>
内存泄漏数量足够大,就会引起内存溢出.或者说内存泄漏是内存溢出的原因之一.


## 3.Android性能优化典范-第2季
#### 1.提升动画性能
1. Bitmap的缩放,旋转,裁剪比较耗性能.例如在一个圆形的钟表图上,我们把时钟的指针抠出来当做单独的图片进行旋转会比旋转一张完整的圆形图性能好.
![](https://user-gold-cdn.xitu.io/2018/9/14/165d76d0bedff35f?w=373&h=173&f=jpeg&s=15468)
2. 尽量减少每次重绘的元素可以极大提升性能.可以把复杂的View拆分会更小的View进行组合,在需要刷新界面时候仅对指定View进行重绘.
    - 假如钟表界面上有很多组件,可以把这些组件做拆分,背景图片单独拎出来设置为一个独立的View,通过setLayerType()方法使得这个View强制用Hardware来进行渲染.至于界面上哪些元素需要做拆分,他们各自的更新频率是多少,需要有针对性的单独讨论
#### 2.对象池
1. 短时间内大量对象被创建然后很快被销毁,会多次触发Android虚拟机在Young generation进行GC,使用AS查看内存曲线,会看到内存曲线剧烈起伏,称为"内存抖动".
2. GC会暂停其他线程,短时间多次GC/内存抖动会引起CPU和GPU在16ms内无法完成当前帧的渲染,引起界面卡顿.
3. 避免内存抖动,可以使用对象池
    - 对象池的作用:减少频繁创建和销毁对象带来的成本,实现对象的缓存和复用
    - [1](https://droidyue.com/blog/2016/12/12/dive-into-object-pool/)
[2](https://www.jianshu.com/p/b981bb758d43)
[3](https://blog.csdn.net/self_study/article/details/51477002) [4](https://blog.csdn.net/zuochunsheng/article/details/54980997)
4. 实例
    ```java
    
    public class User {
        public String id;
        public String name;
        //对象池实例
        private static final SynchronizedPool<User> sPool = new SynchronizedPool<User>(10);
    
        public static User obtain() {
            User instance = sPool.acquire();
            return (instance != null) ? instance : new User();
        }
        public void recycle() {
            sPool.release(this);
        }
    }
    ```

#### 3.for index,for simple,iterator三种遍历性能比较
```java
public class ForTest {
    public static void main(String[] args) {
        Vector<Integer> v = new Vector<>();
        ArrayList<Integer> a = new ArrayList<>();
        LinkedList<Integer> l = new LinkedList<>();
        int time = 1000000;
        for(int i = 0; i< time; i++){
            Integer item = new Random().nextInt(time);
            v.add(item);
            a.add(item);
            l.add(item);
        }
        //测试3种遍历性能
        long start = System.currentTimeMillis();
        for(int i = 0;i<v.size();i++){
            Integer item = v.get(i);
        }
        long end = System.currentTimeMillis();
        System.out.println("for index Vector耗时:"+(end-start)+"ms");
        start = System.currentTimeMillis();
        for(int i = 0;i<a.size();i++){
            Integer item = a.get(i);
        }
        end = System.currentTimeMillis();
        System.out.println("for index ArrayList耗时:"+(end-start)+"ms");
        start = System.currentTimeMillis();
        for(int i = 0;i<l.size();i++){
            Integer item = l.get(i);
        }
        end = System.currentTimeMillis();
        System.out.println("for index LinkedList耗时:"+(end-start)+"ms");
        start = System.currentTimeMillis();
        for(Integer item:v){
            Integer i = item;
        }
        end = System.currentTimeMillis();
        System.out.println("for simple Vector耗时:"+(end-start)+"ms");
        start = System.currentTimeMillis();
        for(Integer item:a){
            Integer i = item;
        }
        end = System.currentTimeMillis();
        System.out.println("for simple ArrayList耗时:"+(end-start)+"ms");
        start = System.currentTimeMillis();
        for(Integer item:l){
            Integer i = item;
        }
        end = System.currentTimeMillis();
        System.out.println("for simple LinkedList耗时:"+(end-start)+"ms");
        start = System.currentTimeMillis();
        for(Iterator i = v.iterator();i.hasNext();){
            Integer item = (Integer) i.next();
        }
        end = System.currentTimeMillis();
        System.out.println("for Iterator Vector耗时:"+(end-start)+"ms");
        start = System.currentTimeMillis();
        for(Iterator i = a.iterator();i.hasNext();){
            Integer item = (Integer) i.next();
        }
        end = System.currentTimeMillis();
        System.out.println("for Iterator ArrayList耗时:"+(end-start)+"ms");
        start = System.currentTimeMillis();
        for(Iterator i = l.iterator();i.hasNext();){
            Integer item = (Integer) i.next();
        }
        end = System.currentTimeMillis();
        System.out.println("for Iterator LinkedList耗时:"+(end-start)+"ms");
    }
}

打印结果:
for index Vector耗时:28ms
for index ArrayList耗时:14ms
LinkedList就不能用for index方式进行遍历.
for simple Vector耗时:68ms
for simple ArrayList耗时:11ms
for simple LinkedList耗时:34ms
for Iterator Vector耗时:49ms
for Iterator ArrayList耗时:12ms
for Iterator LinkedList耗时:0ms
```
1. 不要用for index去遍历链表,因为LinkedList在get任何一个位置的数据的时候,都会把前面的数据走一遍.应该使用Iterator去遍历
    1. get(0),直接拿到0位的Node0的地址,拿到Node0里面的数据
    2. get(1),直接拿到0位的Node0的地址,从0位的Node0中找到下一个1位的Node1的地址,找到Node1,拿到Node1里面的数据
    3. get(2),直接拿到0位的Node0的地址,从0位的Node0中找到下一个1位的Node1的地址,找到Node1,从1位的Node1中找到下一个2位的Node2的地址,找到Node2,拿到Node2里面的数据
2. Vector和ArrayList,使用for index遍历效率较高

#### 4.Merge:通过Merge减少1个View层级
1. 可以将merge当做1个ViewGroup v,如果v的类型和v的父控件的类型一致,那么v其实没必要存在,因为白白增加了布局的深度.所以merge使用时必须保证merge中子控件所应该在的ViewGroup类型和merge所在的父控件类型一致.
2. Merge的使用场景有2个:
    1. Activity的布局文件的根布局是FrameLayout,则将FrameLayout替换为merge
        - 因为setContentView本质就是将布局文件inflate后加载到了id为android.id.content的FrameLayout上.
    2. merge作为根布局的布局文件通过include标签被引入其他布局文件中.这时候include所在的父控件,必须和merge所在的布局文件"原本根布局"一致.
3. 代码示例<br>
merge作为根布局的布局文件,用于Activity的setContentView:
    ```xml
    activity_merge.xml
    
    <?xml version="1.0" encoding="utf-8"?>
    <merge xmlns:android="http://schemas.android.com/apk/res/android"
        android:layout_width="match_parent"
        android:layout_height="match_parent">
        <Button
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="0dp"
            android:text="111111"
            />
        <Button
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginTop="100dp"
            android:layout_marginLeft="40dp"
            android:text="222222"
            />
    </merge>
    ```
    <br>
    merge作为根布局的布局文件,被include标签引入其他布局文件中:
    
    ```xml
    activity_merge_include.xml
    
    <?xml version="1.0" encoding="utf-8"?>
    <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
        android:orientation="vertical" android:layout_width="match_parent"
        android:layout_height="match_parent">
        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="merge被include引用"
            />
        <include
            layout="@layout/activity_merge"
            />
    </LinearLayout>
    ```

#### 5.使用.9.png作为背景
- 典型场景是1个ImageView需要添加1个背景图作为边框.这样边框所在矩形的中间部分和实际显示的图片就好重叠发生Overdraw.
- 可以将背景图制作成.9.png.和前景图重叠部分设置为透明.Android的2D渲染器会优化.9.png的透明区域.

#### 6.减少透明区域对性能的影响
- 不透明的View,显示它只需要渲染一次;如果View设置了alpha值,会至少需要渲染两次,性能不好
    - 设置透明度setAlpha的时候,会把当前view绘制到offscreen buffer中,然后再显示出来.offscreen buffer是 一个临时缓冲区,把View放进来并做透明度的转化,然后显示到屏幕上,这个过程性能差,所以应该尽量避免这个过程
- 如何避免使用offscreen buffer
    1. 对于不存在过度绘制的View,如没有背景的TextView,就可以直接设置文字颜色;ImageView设置图片透明度setImageAlpha;自定义View设置绘制时的paint的透明度
    2. 如果是自定义View,确定不存在过度绘制,可以重写hasOverlappingRendering返回false即可.这样设置alpha时android会自动优化,避免使用offscreen buffer.
        ```java
        @Override
        public boolean hasOverlappingRendering() {
            return false;
        }
        ```
    3. 如果不是1,2两种情况,要设置View的透明度,则需要让GPU来渲染指定View,然后再设置透明度.
        ```java
        View v = findViewById(R.id.root);
        //通过setLayerType的方法来指定View应该如何进行渲染
        //开启硬件加速
        v.setLayerType(View.LAYER_TYPE_HARDWARE,null);
        v.setAlpha(0.60F);
        //透明度设置完毕后关闭硬件加速
        v.setLayerType(View.LAYER_TYPE_NONE,null);
        ```

## 4.Android性能优化典范-第3季
#### 1.避免使用枚举,用注解进行替代
1. 枚举的问题
    1. 每个枚举值都是1个对象,相比较Integer和String常量,枚举的内存开销至少是其2倍.
    2. 过多枚举会增加dex大小及其中的方法数量,增加App占用的空间及引发65536几率
2. 如何替代枚举:使用注解
    1. android.support.annotation中的@IntDef,@StringDef来包装Integer和String常量.
    2. 3个步骤
        1. 首先定义常量
        2. 然后自定义注解,设置取值范围就是刚刚定义的常量,并设置自定义注解的保留范围为源码时/SOURCE
        3. 位指定的属性及方法添加自定义注解.
    3. 代码实例
        ```java
        public class MainActivity extends Activity {
            //1:首先定义常量
            public static final int MALE = 0;
            public static final int FEMALE = 1;
            
            @Override
            protected void onCreate(Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                setContentView(R.layout.main_activity);
                Person person = new Person();
                person.setSex(MALE);
                ((Button) findViewById(R.id.test)).setText(person.getSexDes());
            }
            class Person {
                //3.为指定的属性及方法添加自定义注解
                @SEX
                private int sex;
                //3.为指定的属性及方法添加自定义注解
                public void setSex(@SEX int sex) {
                    this.sex = sex;
                }
                //3.为指定的属性及方法添加自定义注解
                @SEX
                public int getSex() {
                    return sex;
                }
                public String getSexDes() {
                    if (sex == MALE) {
                        return "男";
                    } else {
                        return "女";
                    }
                }
            }
            //2:然后创建自定义注解,设置取值范围就是刚刚定义的常量,并设置自定义注解的保留范围是源码时
            @IntDef({MALE, FEMALE})
            @Retention(RetentionPolicy.SOURCE)
            public @interface SEX {
            }
        }
        ```

## 5.Android内存优化之OOM
#### 如何避免OOM:
1. 减小对象的内存占用
2. 内存对象复用防止重建
3. 避免内存泄漏
4. 内存使用策略优化
#### 1.减小对象的内存占用
1. 避免使用枚举,用注解替代
2. 减小创建的Bitmap的内存,使用合适的缩放比例及解码格式
    1. inSampleSize:缩放比例
    2. decode format:解码格式
#### 2.内存对象的重复利用
1. 对象池技术:减少频繁创建和销毁对象带来的成本,实现对象的缓存和复用
2. 尽量使用Android系统内置资源,可降低APK大小,在一定程度降低内存开销
3. ConvertView的复用
4. LRU的机制实现Bitmap的缓存(图片加载框架的必备机制)
5. 在for循环中,用StringBuilder代替String实现字符串拼接
#### 3.避免内存泄漏
1. 在App中使用leakcanary检测内存泄漏:[leakcanary](https://github.com/square/leakcanary)
2. Activity的内存泄漏
    1. Handler引起Activity内存泄漏
        1. 原因:Handler作为Activity的1个非静态内部类实例,持有Activity实例的引用.若Activity退出后Handler依然有待接收的Message,这时候发生GC,Message-Handler-Activity的引用链导致Activity无法被回收.
        2. 2种解决方法
            1. 在onDestroy调用Handler.removeCallbacksAndMessages(null)移除该Handler关联的所有Message及Runnable.再发生GC,Message已经不存在,就可以顺利的回收Handler及Activity
                ```java
                @Override
                protected void onDestroy() {
                    super.onDestroy();
                    m.removeCallbacksAndMessages(null);
                }
                ```
            2. 自定义静态内部类继承Handler,静态内部类实例不持有外部Activity的引用.在自定义Handler中定义外部Activity的弱引用,只有弱引用关联的外部Activity实例未被回收的情况下才继续执行handleMessage.自定义Handler持有外部Activity的弱引用,发生GC时不耽误Activity被回收.
                ```java
                    static class M extends Handler{
                        WeakReference<Activity> mWeakReference;
                        public M(Activity activity)
                        {
                            mWeakReference=new WeakReference<Activity>(activity);
                        }
                        @Override
                        public void handleMessage(Message msg) {
                            if(mWeakReference != null){
                                Activity activity=mWeakReference.get();
                                if(activity != null){
                                    if(msg.what == 15){
                                        Toast.makeText(activity,"M:15",Toast.LENGTH_SHORT).show();
                                    }
                                    if(msg.what == 5){
                                        Toast.makeText(activity,"M:5",Toast.LENGTH_SHORT).show();
                                    }
                                }
                            }
                        }
                    }
                    private M m;
                    @Override
                    protected void onResume() {
                        super.onResume();
                        m = new M(this);
                        m.sendMessageDelayed(m.obtainMessage(15),15000);
                        m.sendMessageDelayed(m.obtainMessage(5),5000);
                    }
                ```
            
            3. 在避免内存泄漏的前提下,如果要求Activity退出就不执行后续动作,用方法1.如果要求后续动作在GC发生前继续执行,使用方法2
3. Context:尽量使用Application Context而不是Activity Context,避免不经意的内存泄漏
4. 资源对象要及时关闭
#### 4.内存使用策略优化
1. 图片选择合适的文件夹进行存放
    - hdpi/xhdpi/xxhdpi等等不同dpi的文件夹下的图片在不同的设备上会经过scale的处理。例如我们只在hdpi的目录下放置了一张100100的图片，那么根据换算关系，xxhdpi的手机去引用那张图片就会被拉伸到200200。需要注意到在这种情况下，内存占用是会显著提高的。对于不希望被拉伸的图片，需要放到assets或者nodpi的目录下
2. 谨慎使用依赖注入框架.依赖注入框架会扫描代码,需要大量的内存空间映射代码.
3. 混淆可以减少不必要的代码,类,方法等.降低映射代码所需的内存空间
4. onLowMemory()与onTrimMemory():没想到应该怎么用
    1. onLowMemory
        - 当所有的background应用都被kill掉的时候,forground应用会收到onLowMemory()的回调.在这种情况下,需要尽快释放当前应用的非必须的内存资源,从而确保系统能够继续稳定运行
    2. onTrimMemory(int level)
        - 当系统内存达到某些条件的时候,所有正在运行的应用都会收到这个回调,同时在这个回调里面会传递以下的参数,代表不同的内存使用情况,收到onTrimMemory()回调的时候,需要根据传递的参数类型进行判断,合理的选择释放自身的一些内存占用,一方面可以提高系统的整体运行流畅度,另外也可以避免自己被系统判断为优先需要杀掉的应用

## 6.Android开发最佳实践
#### 1.注意对隐式Intent的运行时检查保护
1. 类似打开相机等隐式Intent,不一定能够在所有的Android设备上都正常运行.
    - 例如系统相机应用被关闭或者不存在相机应用,或者某些权限被关闭都可能导致抛出ActivityNotFoundException的异常.
    - 预防这个问题的最佳解决方案是在发出这个隐式Intent之前调用resolveActivity做检查
2. 代码实例
    ```java
    public class IntentCheckActivity extends AppCompatActivity {
        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_intent_check);
        }
        public void openSBTest(View view) {
            // 跳转到"傻逼"软件
            Intent sbIntent = new Intent("android.media.action.IMAGE_GO_SB");
            if (sbIntent.resolveActivity(getPackageManager()) != null) {
                startActivity(sbIntent);
            } else {
                //会弹出这个提示
                Toast.makeText(this,"设备木有傻逼!",Toast.LENGTH_SHORT).show();
            }
        }
        public void openCameraTest(View view) {
            // 跳转到系统照相机
            Intent cameraIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
            if (cameraIntent.resolveActivity(getPackageManager()) != null) {
                startActivity(cameraIntent);
                //正常设备会进入相机并弹出提示
                Toast.makeText(this,"设备有相机!",Toast.LENGTH_LONG).show();
            } else {
                Toast.makeText(this,"设备木有相机!",Toast.LENGTH_SHORT).show();
            }
        }
    }
    ```
#### 2.Android 6.0的权限
#### 3.MD新控件的使用:Toolbar替代ActionBar,AppBarLayout,Navigation Drawer, DrawerLayout, NavigationView等

## 7.Android性能优化典范-第4季
#### 1.网络数据的缓存.okHttp,Picasso都支持网络缓存
[okHttp](https://blog.csdn.net/qq_33463102/article/details/60869879) [Picasso](https://www.cnblogs.com/tonycheng93/p/6381757.html)
#### 2.代码混淆
#### 3.APK瘦身
#### 4.更高效的数据序列化:只是看看从没用过,Protocal Buffers,Nano-Proto-Buffers,FlatBuffers
#### 5.数据呈现的顺序以及结构会对序列化之后的空间产生不小的影响
```java
public final class ZipUtils {

    /**
     * Gzip 压缩数据
     *
     * @param unGzipStr
     * @return
     */
    public static String compressForGzip(String unGzipStr) {

//        if (TextUtils.isEmpty(unGzipStr)) {
//            return null;
//        }
        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            GZIPOutputStream gzip = new GZIPOutputStream(baos);
            gzip.write(unGzipStr.getBytes());
            gzip.close();
            byte[] encode = baos.toByteArray();
            baos.flush();
            baos.close();
//            return Base64Encoder.encode(encode);
            return new String(encode);
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }

        return null;
    }

    /**
     * Gzip解压数据
     *
     * @param gzipStr
     * @return
     */
    public static String decompressForGzip(String gzipStr) {
//        if (TextUtils.isEmpty(gzipStr)) {
//            return null;
//        }
//        byte[] t = Base64Decoder.decodeToBytes(gzipStr);
        byte[] t = gzipStr.getBytes();
        try {
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            ByteArrayInputStream in = new ByteArrayInputStream(t);
            GZIPInputStream gzip = new GZIPInputStream(in);
            byte[] buffer = new byte[1024];
            int n = 0;
            while ((n = gzip.read(buffer, 0, buffer.length)) > 0) {
                out.write(buffer, 0, n);
            }
            gzip.close();
            in.close();
            out.close();
            return out.toString();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
    /**
     * Zip 压缩数据
     *
     * @param unZipStr
     * @return
     */
    public static String compressForZip(String unZipStr) {

//        if (TextUtils.isEmpty(unZipStr)) {
//            return null;
//        }
        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ZipOutputStream zip = new ZipOutputStream(baos);
            zip.putNextEntry(new ZipEntry("0"));
            zip.write(unZipStr.getBytes());
            zip.closeEntry();
            zip.close();
            byte[] encode = baos.toByteArray();
            baos.flush();
            baos.close();
//            return Base64Encoder.encode(encode);
            return new String(encode);
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }

        return null;
    }

    /**
     * Zip解压数据
     *
     * @param zipStr
     * @return
     */
    public static String decompressForZip(String zipStr) {

//        if (TextUtils.isEmpty(zipStr)) {
//            return null;
//        }
//        byte[] t = Base64Decoder.decodeToBytes(zipStr);
        byte[] t = zipStr.getBytes();
        try {
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            ByteArrayInputStream in = new ByteArrayInputStream(t);
            ZipInputStream zip = new ZipInputStream(in);
            zip.getNextEntry();
            byte[] buffer = new byte[1024];
            int n = 0;
            while ((n = zip.read(buffer, 0, buffer.length)) > 0) {
                out.write(buffer, 0, n);
            }
            zip.close();
            in.close();
            out.close();
            return out.toString("UTF-8");
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
}

public class GzipZipTest {
    public static void main(String[] args) {
        GzipZipTest t = new GzipZipTest();
        t.t();
    }
    private void t(){
        /*List<Person> l = new ArrayList<Person>();
        for(int i=0;i<1;i++){
            for(int j=0;j<6000;j++){
                Person p = new Person();
                p.age = j;
                p.gender = "gender"+j;
                p.name = "name"+j;
                l.add(p);
            }
        }
        Gson gson = new Gson();
        List<String> names = new ArrayList<String>();
        List<String> genders = new ArrayList<String>();
        List<Integer> ages = new ArrayList<Integer>();
        for(Person p:l){
            names.add(p.name);
            genders.add(p.gender);
            ages.add(p.age);
        }
        PersonItemList itemList = new PersonItemList();
        itemList.items = l;
        String jsonDataOri = gson.toJson(itemList);
        System.out.println("原始数据结构 压缩前json数据长度 ---->" + jsonDataOri.length());
        PersonAttrList attrList = new PersonAttrList();
        attrList.names = names;
        attrList.genders = genders;
        attrList.ages = ages;
        String jsonDataVariety = gson.toJson(attrList);
        System.out.println("变种数据结构 压缩前json数据长度 ---->" + jsonDataVariety.length());
        System.out.println("===================================================");

        for(int i=0;i<100;i++){
            //1:原始数据结构
            //Gzip压缩
            long start = System.currentTimeMillis();
            String gzipStr = ZipUtils.compressForGzip(jsonDataOri);
            long end = System.currentTimeMillis();
            System.out.println("原始数据结构 Gzip压缩耗时 cost time---->" + (end - start));
            System.out.println("原始数据结构 Gzip压缩后json数据长度 ---->" + gzipStr.length());
            //Zip压缩
//        start = System.currentTimeMillis();
//        String zipStr = ZipUtils.compressForZip(jsonDataOri);
//        end = System.currentTimeMillis();
//        System.out.println("原始数据结构 Zip压缩耗时 cost time---->" + (end - start));
//        System.out.println("原始数据结构 Zip压缩后json数据长度 ---->" + zipStr.length());

            //2:变种数据结构
            //Gzip压缩
            start = System.currentTimeMillis();
            String gzipStrVariety = ZipUtils.compressForGzip(jsonDataVariety);
            end = System.currentTimeMillis();
            System.out.println("变种数据结构 Gzip压缩耗时 cost time---->" + (end - start));
            System.out.println("变种数据结构 Gzip压缩后json数据长度 ---->" + gzipStrVariety.length());
            //Zip压缩
//        start = System.currentTimeMillis();
//        String zipStrVariety = ZipUtils.compressForZip(jsonDataVariety);
//        end = System.currentTimeMillis();
//        System.out.println("变种数据结构 Zip压缩耗时 cost time---->" + (end - start));
//        System.out.println("变种数据结构 Zip压缩后json数据长度 ---->" + zipStrVariety.length());
            System.out.println("压缩后 原始结构长度:变种数据结构="+((float)gzipStr.length())/(float)gzipStrVariety.length());
            System.out.println("===================================================");
        }*/

        float repetitionRatio = 0.00F;
        List<Person> l = new ArrayList<Person>();
        for(repetitionRatio = 0.00F; repetitionRatio < 1.00F; repetitionRatio+=0.01F){
            int reportIndex = (int) (6000 * (1-repetitionRatio));
            for(int i = 0;i<reportIndex;i++){
                Person p = new Person();
                p.age = i;
                p.gender = "gender"+i;
                p.name = "name"+i;
                l.add(p);
            }
            if(repetitionRatio > 0.00F){
                int reportCount = (int) (6000 * repetitionRatio);
                for(int i = 0;i<reportCount;i++){
                    Person p = new Person();
                    p.age = i;
                    p.gender = "gender"+i;
                    p.name = "name"+i;
                    l.add(p);
                }
            }
            Gson gson = new Gson();
            List<String> names = new ArrayList<String>();
            List<String> genders = new ArrayList<String>();
            List<Integer> ages = new ArrayList<Integer>();
            for(Person p:l){
                names.add(p.name);
                genders.add(p.gender);
                ages.add(p.age);
            }
            PersonItemList itemList = new PersonItemList();
            itemList.items = l;
            String jsonDataOri = gson.toJson(itemList);
            System.out.println("===================================================");
            System.out.println("原始数据结构 压缩前json数据长度 ---->" + jsonDataOri.length());
            PersonAttrList attrList = new PersonAttrList();
            attrList.names = names;
            attrList.genders = genders;
            attrList.ages = ages;
            String jsonDataVariety = gson.toJson(attrList);
            System.out.println("变种数据结构 压缩前json数据长度 ---->" + jsonDataVariety.length());
            //1:原始数据结构
            //Gzip压缩
            long start = System.currentTimeMillis();
            String gzipStr = ZipUtils.compressForGzip(jsonDataOri);
            long end = System.currentTimeMillis();
            System.out.println("原始数据结构 Gzip压缩后json数据长度 ---->" + gzipStr.length());

            //2:变种数据结构
            //Gzip压缩
            start = System.currentTimeMillis();
            String gzipStrVariety = ZipUtils.compressForGzip(jsonDataVariety);
            end = System.currentTimeMillis();
            System.out.println("变种数据结构 Gzip压缩后json数据长度 ---->" + gzipStrVariety.length());
            System.out.println("重复率为 "+repetitionRatio+" 压缩后:原始结构长度:变种数据结构="+((float)gzipStr.length())/(float)gzipStrVariety.length());
        }
    }
    public class Person implements Serializable{
        public String name;
        public String gender;
        public int age;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public String getGender() {
            return gender;
        }

        public void setGender(String gender) {
            this.gender = gender;
        }

        public int getAge() {
            return age;
        }

        public void setAge(int age) {
            this.age = age;
        }
    }
    public class PersonItemList implements Serializable{
        public List<Person> items;

        public List<Person> getItems() {
            return items;
        }

        public void setItems(List<Person> items) {
            this.items = items;
        }
    }
    public class PersonAttrList implements Serializable{
        public List<String> names;
        public List<String> genders;
        public List<Integer> ages;

        public List<String> getNames() {
            return names;
        }

        public void setNames(List<String> names) {
            this.names = names;
        }

        public List<String> getGenders() {
            return genders;
        }

        public void setGenders(List<String> genders) {
            this.genders = genders;
        }

        public List<Integer> getAges() {
            return ages;
        }

        public void setAges(List<Integer> ages) {
            this.ages = ages;
        }
    }
}

当每个对象属性重复率超过100%的情况下打印结果:

List<Person> l = new ArrayList<Person>();
        for(int i=0;i<1;i++){
            for(int j=0;j<6000;j++){
                Person p = new Person();
                p.age = j;
                p.gender = "gender"+j;
                p.name = "name"+j;
                l.add(p);
            }
}

原始数据结构 压缩前json数据长度 ---->273011	//因为i和j变动,数据会略有变化
变种数据结构 压缩前json数据长度 ---->129032	//因为i和j变动,数据会略有变化

i=x;	j=y;

x=1;	j=6000;
原始数据结构 Gzip压缩后json数据长度 ---->44215
变种数据结构 Gzip压缩后json数据长度 ---->39561
压缩后 原始结构长度:变种数据结构=1.1176411

x=2;	j=3000;
原始数据结构 Gzip压缩后json数据长度 ---->44204
变种数据结构 Gzip压缩后json数据长度 ---->27628
压缩后 原始结构长度:变种数据结构=1.599971

x=3;	j=2000;
原始数据结构 Gzip压缩后json数据长度 ---->43733
变种数据结构 Gzip压缩后json数据长度 ---->17020
压缩后 原始结构长度:变种数据结构=2.5695064

x=4;	j=1500;
原始数据结构 Gzip压缩后json数据长度 ---->43398
变种数据结构 Gzip压缩后json数据长度 ---->13914
压缩后 原始结构长度:变种数据结构=3.119017

x=6;	j=1000;
原始数据结构 Gzip压缩后json数据长度 ---->42166
变种数据结构 Gzip压缩后json数据长度 ---->8016
压缩后 原始结构长度:变种数据结构=5.2602296

x=7;	j=857;
原始数据结构 Gzip压缩后json数据长度 ---->41743
变种数据结构 Gzip压缩后json数据长度 ---->7024
压缩后 原始结构长度:变种数据结构=5.94291

x=8;	j=750;
原始数据结构 Gzip压缩后json数据长度 ---->41561
变种数据结构 Gzip压缩后json数据长度 ---->6378
压缩后 原始结构长度:变种数据结构=6.516306

x=9;	j=667;
原始数据结构 Gzip压缩后json数据长度 ---->41491
变种数据结构 Gzip压缩后json数据长度 ---->5870
压缩后 原始结构长度:变种数据结构=7.0683136

x=10;	j=600;
原始数据结构 Gzip压缩后json数据长度 ---->7552
变种数据结构 Gzip压缩后json数据长度 ---->5503
压缩后 原始结构长度:变种数据结构=1.3723423

x=12;	j=500;
原始数据结构 Gzip压缩后json数据长度 ---->6955
变种数据结构 Gzip压缩后json数据长度 ---->4962
压缩后 原始结构长度:变种数据结构=1.4016526

x=15;	j=400;
原始数据结构 Gzip压缩后json数据长度 ---->6207
变种数据结构 Gzip压缩后json数据长度 ---->4179
压缩后 原始结构长度:变种数据结构=1.4852836

x=20;	j=300;
原始数据结构 Gzip压缩后json数据长度 ---->5117
变种数据结构 Gzip压缩后json数据长度 ---->3576
压缩后 原始结构长度:变种数据结构=1.4309285

x=30;	j=200;
原始数据结构 Gzip压缩后json数据长度 ---->4511
变种数据结构 Gzip压缩后json数据长度 ---->3156
压缩后 原始结构长度:变种数据结构=1.429341

x=40;	j=150;
原始数据结构 Gzip压缩后json数据长度 ---->4359
变种数据结构 Gzip压缩后json数据长度 ---->3035
压缩后 原始结构长度:变种数据结构=1.4362438

x=60;	j=100;
原始数据结构 Gzip压缩后json数据长度 ---->2832
变种数据结构 Gzip压缩后json数据长度 ---->1382
压缩后 原始结构长度:变种数据结构=2.049204

x=80;	j=75;
原始数据结构 Gzip压缩后json数据长度 ---->2581
变种数据结构 Gzip压缩后json数据长度 ---->1217
压缩后 原始结构长度:变种数据结构=2.1207888

x=150;	j=40;
原始数据结构 Gzip压缩后json数据长度 ---->1835
变种数据结构 Gzip压缩后json数据长度 ---->890
压缩后 原始结构长度:变种数据结构=2.0617979

x=200;	j=30;
原始数据结构 Gzip压缩后json数据长度 ---->1744
变种数据结构 Gzip压缩后json数据长度 ---->797
压缩后 原始结构长度:变种数据结构=2.1882057

x=300;	j=20;
原始数据结构 Gzip压缩后json数据长度 ---->1539
变种数据结构 Gzip压缩后json数据长度 ---->739
压缩后 原始结构长度:变种数据结构=2.082544

x=316;	j=19;
原始数据结构 Gzip压缩后json数据长度 ---->1269
变种数据结构 Gzip压缩后json数据长度 ---->725
压缩后 原始结构长度:变种数据结构=1.7503449

x=400;	j=15;
原始数据结构 Gzip压缩后json数据长度 ---->1488
变种数据结构 Gzip压缩后json数据长度 ---->662
压缩后 原始结构长度:变种数据结构=2.247734

x=500;	j=12;
原始数据结构 Gzip压缩后json数据长度 ---->1453
变种数据结构 Gzip压缩后json数据长度 ---->563
压缩后 原始结构长度:变种数据结构=2.580817

x=600;	j=10;
原始数据结构 Gzip压缩后json数据长度 ---->1044
变种数据结构 Gzip压缩后json数据长度 ---->573
压缩后 原始结构长度:变种数据结构=1.8219895

x=667;	j=9;
原始数据结构 Gzip压缩后json数据长度 ---->1291
变种数据结构 Gzip压缩后json数据长度 ---->527
压缩后 原始结构长度:变种数据结构=2.4497154

x=750;	j=8;
原始数据结构 Gzip压缩后json数据长度 ---->1155
变种数据结构 Gzip压缩后json数据长度 ---->520
压缩后 原始结构长度:变种数据结构=2.2211537

x=1000;	j=6;
原始数据结构 Gzip压缩后json数据长度 ---->1269
变种数据结构 Gzip压缩后json数据长度 ---->429
压缩后 原始结构长度:变种数据结构=2.958042

x=1200;	j=5;
原始数据结构 Gzip压缩后json数据长度 ---->1135
变种数据结构 Gzip压缩后json数据长度 ---->478
压缩后 原始结构长度:变种数据结构=2.374477

x=3000;	j=2;
原始数据结构 Gzip压缩后json数据长度 ---->990
变种数据结构 Gzip压缩后json数据长度 ---->382
压缩后 原始结构长度:变种数据结构=2.591623

x=6000;	j=1;
原始数据结构 Gzip压缩后json数据长度 ---->590
变种数据结构 Gzip压缩后json数据长度 ---->311
压缩后 原始结构长度:变种数据结构=1.897106

当每个对象属性重复率低于100%的情况下打印结果:
===================================================
原始数据结构 压缩前json数据长度 ---->314681
变种数据结构 压缩前json数据长度 ---->170702
原始数据结构 Gzip压缩后json数据长度 ---->44215
变种数据结构 Gzip压缩后json数据长度 ---->39561
重复率为 0.0 压缩后:原始结构长度:变种数据结构=1.1176411
===================================================
原始数据结构 压缩前json数据长度 ---->628961
变种数据结构 压缩前json数据长度 ---->340982
原始数据结构 Gzip压缩后json数据长度 ---->88245
变种数据结构 Gzip压缩后json数据长度 ---->67222
重复率为 0.01 压缩后:原始结构长度:变种数据结构=1.3127398
===================================================
原始数据结构 压缩前json数据长度 ---->942941
变种数据结构 压缩前json数据长度 ---->510962
原始数据结构 Gzip压缩后json数据长度 ---->131646
变种数据结构 Gzip压缩后json数据长度 ---->91273
重复率为 0.02 压缩后:原始结构长度:变种数据结构=1.4423324
===================================================
原始数据结构 压缩前json数据长度 ---->1256741
变种数据结构 压缩前json数据长度 ---->680762
原始数据结构 Gzip压缩后json数据长度 ---->175096
变种数据结构 Gzip压缩后json数据长度 ---->117218
重复率为 0.03 压缩后:原始结构长度:变种数据结构=1.4937638
===================================================
原始数据结构 压缩前json数据长度 ---->1570361
变种数据结构 压缩前json数据长度 ---->850382
原始数据结构 Gzip压缩后json数据长度 ---->217916
变种数据结构 Gzip压缩后json数据长度 ---->142465
重复率为 0.04 压缩后:原始结构长度:变种数据结构=1.5296108
===================================================
原始数据结构 压缩前json数据长度 ---->1883751
变种数据结构 压缩前json数据长度 ---->1019796
原始数据结构 Gzip压缩后json数据长度 ---->260431
变种数据结构 Gzip压缩后json数据长度 ---->168192
重复率为 0.049999997 压缩后:原始结构长度:变种数据结构=1.548415
===================================================
原始数据结构 压缩前json数据长度 ---->2196961
变种数据结构 压缩前json数据长度 ---->1189030
原始数据结构 Gzip压缩后json数据长度 ---->302306
变种数据结构 Gzip压缩后json数据长度 ---->190830
重复率为 0.059999995 压缩后:原始结构长度:变种数据结构=1.5841639
===================================================
原始数据结构 压缩前json数据长度 ---->2509991
变种数据结构 压缩前json数据长度 ---->1358084
原始数据结构 Gzip压缩后json数据长度 ---->344364
变种数据结构 Gzip压缩后json数据长度 ---->217196
重复率为 0.06999999 压缩后:原始结构长度:变种数据结构=1.5854988
===================================================
原始数据结构 压缩前json数据长度 ---->2822841
变种数据结构 压缩前json数据长度 ---->1526958
原始数据结构 Gzip压缩后json数据长度 ---->385683
变种数据结构 Gzip压缩后json数据长度 ---->242823
重复率为 0.07999999 压缩后:原始结构长度:变种数据结构=1.5883298
===================================================
原始数据结构 压缩前json数据长度 ---->3135511
变种数据结构 压缩前json数据长度 ---->1695652
原始数据结构 Gzip压缩后json数据长度 ---->427123
变种数据结构 Gzip压缩后json数据长度 ---->263331
重复率为 0.08999999 压缩后:原始结构长度:变种数据结构=1.6220005
===================================================
原始数据结构 压缩前json数据长度 ---->3448001
变种数据结构 压缩前json数据长度 ---->1864166
原始数据结构 Gzip压缩后json数据长度 ---->467518
变种数据结构 Gzip压缩后json数据长度 ---->288576
重复率为 0.09999999 压缩后:原始结构长度:变种数据结构=1.6200862
===================================================
原始数据结构 压缩前json数据长度 ---->3760311
变种数据结构 压缩前json数据长度 ---->2032500
原始数据结构 Gzip压缩后json数据长度 ---->508073
变种数据结构 Gzip压缩后json数据长度 ---->311277
重复率为 0.109999985 压缩后:原始结构长度:变种数据结构=1.6322215
===================================================
原始数据结构 压缩前json数据长度 ---->4072441
变种数据结构 压缩前json数据长度 ---->2200654
原始数据结构 Gzip压缩后json数据长度 ---->552311
变种数据结构 Gzip压缩后json数据长度 ---->334727
重复率为 0.11999998 压缩后:原始结构长度:变种数据结构=1.6500342
===================================================
原始数据结构 压缩前json数据长度 ---->4384391
变种数据结构 压缩前json数据长度 ---->2368628
原始数据结构 Gzip压缩后json数据长度 ---->596609
变种数据结构 Gzip压缩后json数据长度 ---->360012
重复率为 0.12999998 压缩后:原始结构长度:变种数据结构=1.657192
===================================================
原始数据结构 压缩前json数据长度 ---->4696161
变种数据结构 压缩前json数据长度 ---->2536422
原始数据结构 Gzip压缩后json数据长度 ---->640073
变种数据结构 Gzip压缩后json数据长度 ---->379991
重复率为 0.13999999 压缩后:原始结构长度:变种数据结构=1.6844425
===================================================
原始数据结构 压缩前json数据长度 ---->5007751
变种数据结构 压缩前json数据长度 ---->2704036
原始数据结构 Gzip压缩后json数据长度 ---->683580
变种数据结构 Gzip压缩后json数据长度 ---->405515
重复率为 0.14999999 压缩后:原始结构长度:变种数据结构=1.6857083
===================================================
原始数据结构 压缩前json数据长度 ---->5319211
变种数据结构 压缩前json数据长度 ---->2871496
原始数据结构 Gzip压缩后json数据长度 ---->727355
变种数据结构 Gzip压缩后json数据长度 ---->425179
重复率为 0.16 压缩后:原始结构长度:变种数据结构=1.710703
===================================================
原始数据结构 压缩前json数据长度 ---->5630551
变种数据结构 压缩前json数据长度 ---->3038836
原始数据结构 Gzip压缩后json数据长度 ---->771548
变种数据结构 Gzip压缩后json数据长度 ---->447295
重复率为 0.17 压缩后:原始结构长度:变种数据结构=1.7249198
===================================================
原始数据结构 压缩前json数据长度 ---->5941891
变种数据结构 压缩前json数据长度 ---->3206176
原始数据结构 Gzip压缩后json数据长度 ---->815285
变种数据结构 Gzip压缩后json数据长度 ---->470223
重复率为 0.18 压缩后:原始结构长度:变种数据结构=1.7338263
===================================================
原始数据结构 压缩前json数据长度 ---->6253231
变种数据结构 压缩前json数据长度 ---->3373516
原始数据结构 Gzip压缩后json数据长度 ---->859535
变种数据结构 Gzip压缩后json数据长度 ---->489396
重复率为 0.19000001 压缩后:原始结构长度:变种数据结构=1.756318
===================================================
原始数据结构 压缩前json数据长度 ---->6564518
变种数据结构 压缩前json数据长度 ---->3540827
原始数据结构 Gzip压缩后json数据长度 ---->903925
变种数据结构 Gzip压缩后json数据长度 ---->510873
重复率为 0.20000002 压缩后:原始结构长度:变种数据结构=1.7693732
===================================================
原始数据结构 压缩前json数据长度 ---->6875858
变种数据结构 压缩前json数据长度 ---->3708167
原始数据结构 Gzip压缩后json数据长度 ---->948289
变种数据结构 Gzip压缩后json数据长度 ---->531857
重复率为 0.21000002 压缩后:原始结构长度:变种数据结构=1.7829773
===================================================
原始数据结构 压缩前json数据长度 ---->7187198
变种数据结构 压缩前json数据长度 ---->3875507
原始数据结构 Gzip压缩后json数据长度 ---->992424
变种数据结构 Gzip压缩后json数据长度 ---->553380
重复率为 0.22000003 压缩后:原始结构长度:变种数据结构=1.7933861
===================================================
原始数据结构 压缩前json数据长度 ---->7498538
变种数据结构 压缩前json数据长度 ---->4042847
原始数据结构 Gzip压缩后json数据长度 ---->1036813
变种数据结构 Gzip压缩后json数据长度 ---->573072
重复率为 0.23000003 压缩后:原始结构长度:变种数据结构=1.8092195
===================================================
原始数据结构 压缩前json数据长度 ---->7809878
变种数据结构 压缩前json数据长度 ---->4210187
原始数据结构 Gzip压缩后json数据长度 ---->1081568
变种数据结构 Gzip压缩后json数据长度 ---->593819
重复率为 0.24000004 压缩后:原始结构长度:变种数据结构=1.8213766
===================================================
原始数据结构 压缩前json数据长度 ---->8121218
变种数据结构 压缩前json数据长度 ---->4377527
原始数据结构 Gzip压缩后json数据长度 ---->1126113
变种数据结构 Gzip压缩后json数据长度 ---->615754
重复率为 0.25000003 压缩后:原始结构长度:变种数据结构=1.8288358
===================================================
原始数据结构 压缩前json数据长度 ---->8432558
变种数据结构 压缩前json数据长度 ---->4544867
原始数据结构 Gzip压缩后json数据长度 ---->1169974
变种数据结构 Gzip压缩后json数据长度 ---->635451
重复率为 0.26000002 压缩后:原始结构长度:变种数据结构=1.841171
===================================================
原始数据结构 压缩前json数据长度 ---->8743898
变种数据结构 压缩前json数据长度 ---->4712207
原始数据结构 Gzip压缩后json数据长度 ---->1213941
变种数据结构 Gzip压缩后json数据长度 ---->658539
重复率为 0.27 压缩后:原始结构长度:变种数据结构=1.8433851
===================================================
原始数据结构 压缩前json数据长度 ---->9055238
变种数据结构 压缩前json数据长度 ---->4879547
原始数据结构 Gzip压缩后json数据长度 ---->1257850
变种数据结构 Gzip压缩后json数据长度 ---->678042
重复率为 0.28 压缩后:原始结构长度:变种数据结构=1.855121
===================================================
原始数据结构 压缩前json数据长度 ---->9366578
变种数据结构 压缩前json数据长度 ---->5046887
原始数据结构 Gzip压缩后json数据长度 ---->1302499
变种数据结构 Gzip压缩后json数据长度 ---->694028
重复率为 0.29 压缩后:原始结构长度:变种数据结构=1.876724
===================================================
原始数据结构 压缩前json数据长度 ---->9677865
变种数据结构 压缩前json数据长度 ---->5214198
原始数据结构 Gzip压缩后json数据长度 ---->1346660
变种数据结构 Gzip压缩后json数据长度 ---->716725
重复率为 0.29999998 压缩后:原始结构长度:变种数据结构=1.8789076
===================================================
原始数据结构 压缩前json数据长度 ---->9989152
变种数据结构 压缩前json数据长度 ---->5381509
原始数据结构 Gzip压缩后json数据长度 ---->1391298
变种数据结构 Gzip压缩后json数据长度 ---->733770
重复率为 0.30999997 压缩后:原始结构长度:变种数据结构=1.8960955
===================================================
原始数据结构 压缩前json数据长度 ---->10300439
变种数据结构 压缩前json数据长度 ---->5548820
原始数据结构 Gzip压缩后json数据长度 ---->1435687
变种数据结构 Gzip压缩后json数据长度 ---->748608
重复率为 0.31999996 压缩后:原始结构长度:变种数据结构=1.9178088
===================================================
原始数据结构 压缩前json数据长度 ---->10611726
变种数据结构 压缩前json数据长度 ---->5716131
原始数据结构 Gzip压缩后json数据长度 ---->1478899
变种数据结构 Gzip压缩后json数据长度 ---->768487
重复率为 0.32999995 压缩后:原始结构长度:变种数据结构=1.9244294
===================================================
原始数据结构 压缩前json数据长度 ---->10923013
变种数据结构 压缩前json数据长度 ---->5883442
原始数据结构 Gzip压缩后json数据长度 ---->1523871
变种数据结构 Gzip压缩后json数据长度 ---->790046
重复率为 0.33999994 压缩后:原始结构长度:变种数据结构=1.9288384
===================================================
原始数据结构 压缩前json数据长度 ---->11234300
变种数据结构 压缩前json数据长度 ---->6050753
原始数据结构 Gzip压缩后json数据长度 ---->1567904
变种数据结构 Gzip压缩后json数据长度 ---->806764
重复率为 0.34999993 压缩后:原始结构长度:变种数据结构=1.9434482
===================================================
原始数据结构 压缩前json数据长度 ---->11545587
变种数据结构 压缩前json数据长度 ---->6218064
原始数据结构 Gzip压缩后json数据长度 ---->1612025
变种数据结构 Gzip压缩后json数据长度 ---->825082
重复率为 0.35999992 压缩后:原始结构长度:变种数据结构=1.9537755
===================================================
原始数据结构 压缩前json数据长度 ---->11856874
变种数据结构 压缩前json数据长度 ---->6385375
原始数据结构 Gzip压缩后json数据长度 ---->1656309
变种数据结构 Gzip压缩后json数据长度 ---->841081
重复率为 0.36999992 压缩后:原始结构长度:变种数据结构=1.9692621
===================================================
原始数据结构 压缩前json数据长度 ---->12168161
变种数据结构 压缩前json数据长度 ---->6552686
原始数据结构 Gzip压缩后json数据长度 ---->1701053
变种数据结构 Gzip压缩后json数据长度 ---->859670
重复率为 0.3799999 压缩后:原始结构长度:变种数据结构=1.9787279
===================================================
原始数据结构 压缩前json数据长度 ---->12479448
变种数据结构 压缩前json数据长度 ---->6719997
原始数据结构 Gzip压缩后json数据长度 ---->1744778
变种数据结构 Gzip压缩后json数据长度 ---->876910
重复率为 0.3899999 压缩后:原始结构长度:变种数据结构=1.9896888
===================================================
原始数据结构 压缩前json数据长度 ---->12790735
变种数据结构 压缩前json数据长度 ---->6887308
原始数据结构 Gzip压缩后json数据长度 ---->1788558
变种数据结构 Gzip压缩后json数据长度 ---->893617
重复率为 0.3999999 压缩后:原始结构长度:变种数据结构=2.0014815
===================================================
原始数据结构 压缩前json数据长度 ---->13102022
变种数据结构 压缩前json数据长度 ---->7054619
原始数据结构 Gzip压缩后json数据长度 ---->1832606
变种数据结构 Gzip压缩后json数据长度 ---->909268
重复率为 0.40999988 压缩后:原始结构长度:变种数据结构=2.015474
===================================================
原始数据结构 压缩前json数据长度 ---->13413309
变种数据结构 压缩前json数据长度 ---->7221930
原始数据结构 Gzip压缩后json数据长度 ---->1876091
变种数据结构 Gzip压缩后json数据长度 ---->928388
重复率为 0.41999987 压缩后:原始结构长度:变种数据结构=2.020805
===================================================
原始数据结构 压缩前json数据长度 ---->13724596
变种数据结构 压缩前json数据长度 ---->7389241
原始数据结构 Gzip压缩后json数据长度 ---->1919980
变种数据结构 Gzip压缩后json数据长度 ---->943277
重复率为 0.42999986 压缩后:原始结构长度:变种数据结构=2.0354362
===================================================
原始数据结构 压缩前json数据长度 ---->14035883
变种数据结构 压缩前json数据长度 ---->7556552
原始数据结构 Gzip压缩后json数据长度 ---->1963806
变种数据结构 Gzip压缩后json数据长度 ---->955426
重复率为 0.43999985 压缩后:原始结构长度:变种数据结构=2.0554245
===================================================
原始数据结构 压缩前json数据长度 ---->14347170
变种数据结构 压缩前json数据长度 ---->7723863
原始数据结构 Gzip压缩后json数据长度 ---->2008255
变种数据结构 Gzip压缩后json数据长度 ---->978913
重复率为 0.44999984 压缩后:原始结构长度:变种数据结构=2.0515153
===================================================
原始数据结构 压缩前json数据长度 ---->14658457
变种数据结构 压缩前json数据长度 ---->7891174
原始数据结构 Gzip压缩后json数据长度 ---->2052622
变种数据结构 Gzip压缩后json数据长度 ---->1000320
重复率为 0.45999983 压缩后:原始结构长度:变种数据结构=2.0519655
===================================================
原始数据结构 压缩前json数据长度 ---->14969744
变种数据结构 压缩前json数据长度 ---->8058485
原始数据结构 Gzip压缩后json数据长度 ---->2097560
变种数据结构 Gzip压缩后json数据长度 ---->1018890
重复率为 0.46999982 压缩后:原始结构长度:变种数据结构=2.0586717
===================================================
原始数据结构 压缩前json数据长度 ---->15281031
变种数据结构 压缩前json数据长度 ---->8225796
原始数据结构 Gzip压缩后json数据长度 ---->2141606
变种数据结构 Gzip压缩后json数据长度 ---->1039701
重复率为 0.4799998 压缩后:原始结构长度:变种数据结构=2.0598288
===================================================
原始数据结构 压缩前json数据长度 ---->15592318
变种数据结构 压缩前json数据长度 ---->8393107
原始数据结构 Gzip压缩后json数据长度 ---->2186211
变种数据结构 Gzip压缩后json数据长度 ---->1057394
重复率为 0.4899998 压缩后:原始结构长度:变种数据结构=2.0675464
===================================================
原始数据结构 压缩前json数据长度 ---->15903605
变种数据结构 压缩前json数据长度 ---->8560418
原始数据结构 Gzip压缩后json数据长度 ---->2230291
变种数据结构 Gzip压缩后json数据长度 ---->1070577
重复率为 0.4999998 压缩后:原始结构长度:变种数据结构=2.0832608
===================================================
原始数据结构 压缩前json数据长度 ---->16214892
变种数据结构 压缩前json数据长度 ---->8727729
原始数据结构 Gzip压缩后json数据长度 ---->2274591
变种数据结构 Gzip压缩后json数据长度 ---->1088015
重复率为 0.5099998 压缩后:原始结构长度:变种数据结构=2.0905879
===================================================
原始数据结构 压缩前json数据长度 ---->16526179
变种数据结构 压缩前json数据长度 ---->8895040
原始数据结构 Gzip压缩后json数据长度 ---->2318925
变种数据结构 Gzip压缩后json数据长度 ---->1105132
重复率为 0.5199998 压缩后:原始结构长度:变种数据结构=2.098324
===================================================
原始数据结构 压缩前json数据长度 ---->16837466
变种数据结构 压缩前json数据长度 ---->9062351
原始数据结构 Gzip压缩后json数据长度 ---->2362868
变种数据结构 Gzip压缩后json数据长度 ---->1126356
重复率为 0.5299998 压缩后:原始结构长度:变种数据结构=2.0977986
===================================================
原始数据结构 压缩前json数据长度 ---->17148753
变种数据结构 压缩前json数据长度 ---->9229662
原始数据结构 Gzip压缩后json数据长度 ---->2406998
变种数据结构 Gzip压缩后json数据长度 ---->1145873
重复率为 0.5399998 压缩后:原始结构长度:变种数据结构=2.10058
===================================================
原始数据结构 压缩前json数据长度 ---->17460040
变种数据结构 压缩前json数据长度 ---->9396973
原始数据结构 Gzip压缩后json数据长度 ---->2450976
变种数据结构 Gzip压缩后json数据长度 ---->1166866
重复率为 0.5499998 压缩后:原始结构长度:变种数据结构=2.1004777
===================================================
原始数据结构 压缩前json数据长度 ---->17771327
变种数据结构 压缩前json数据长度 ---->9564284
原始数据结构 Gzip压缩后json数据长度 ---->2495554
变种数据结构 Gzip压缩后json数据长度 ---->1186790
重复率为 0.55999976 压缩后:原始结构长度:变种数据结构=2.1027763
===================================================
原始数据结构 压缩前json数据长度 ---->18082614
变种数据结构 压缩前json数据长度 ---->9731595
原始数据结构 Gzip压缩后json数据长度 ---->2540012
变种数据结构 Gzip压缩后json数据长度 ---->1205558
重复率为 0.56999975 压缩后:原始结构长度:变种数据结构=2.106918
===================================================
原始数据结构 压缩前json数据长度 ---->18393901
变种数据结构 压缩前json数据长度 ---->9898906
原始数据结构 Gzip压缩后json数据长度 ---->2583505
变种数据结构 Gzip压缩后json数据长度 ---->1219319
重复率为 0.57999974 压缩后:原始结构长度:变种数据结构=2.1188097
===================================================
原始数据结构 压缩前json数据长度 ---->18705188
变种数据结构 压缩前json数据长度 ---->10066217
原始数据结构 Gzip压缩后json数据长度 ---->2627699
变种数据结构 Gzip压缩后json数据长度 ---->1234478
重复率为 0.58999974 压缩后:原始结构长度:变种数据结构=2.1285913
===================================================
原始数据结构 压缩前json数据长度 ---->19016475
变种数据结构 压缩前json数据长度 ---->10233528
原始数据结构 Gzip压缩后json数据长度 ---->2671442
变种数据结构 Gzip压缩后json数据长度 ---->1252359
重复率为 0.5999997 压缩后:原始结构长度:变种数据结构=2.133128
===================================================
原始数据结构 压缩前json数据长度 ---->19327762
变种数据结构 压缩前json数据长度 ---->10400839
原始数据结构 Gzip压缩后json数据长度 ---->2715746
变种数据结构 Gzip压缩后json数据长度 ---->1272445
重复率为 0.6099997 压缩后:原始结构长度:变种数据结构=2.1342738
===================================================
原始数据结构 压缩前json数据长度 ---->19639049
变种数据结构 压缩前json数据长度 ---->10568150
原始数据结构 Gzip压缩后json数据长度 ---->2760349
变种数据结构 Gzip压缩后json数据长度 ---->1291213
重复率为 0.6199997 压缩后:原始结构长度:变种数据结构=2.1377952
===================================================
原始数据结构 压缩前json数据长度 ---->19950336
变种数据结构 压缩前json数据长度 ---->10735461
原始数据结构 Gzip压缩后json数据长度 ---->2804533
变种数据结构 Gzip压缩后json数据长度 ---->1307714
重复率为 0.6299997 压缩后:原始结构长度:变种数据结构=2.1446073
===================================================
原始数据结构 压缩前json数据长度 ---->20261623
变种数据结构 压缩前json数据长度 ---->10902772
原始数据结构 Gzip压缩后json数据长度 ---->2849182
变种数据结构 Gzip压缩后json数据长度 ---->1324197
重复率为 0.6399997 压缩后:原始结构长度:变种数据结构=2.15163
===================================================
原始数据结构 压缩前json数据长度 ---->20572910
变种数据结构 压缩前json数据长度 ---->11070083
原始数据结构 Gzip压缩后json数据长度 ---->2893785
变种数据结构 Gzip压缩后json数据长度 ---->1341530
重复率为 0.6499997 压缩后:原始结构长度:变种数据结构=2.157078
===================================================
原始数据结构 压缩前json数据长度 ---->20884197
变种数据结构 压缩前json数据长度 ---->11237394
原始数据结构 Gzip压缩后json数据长度 ---->2938467
变种数据结构 Gzip压缩后json数据长度 ---->1358455
重复率为 0.65999967 压缩后:原始结构长度:变种数据结构=2.1630948
===================================================
原始数据结构 压缩前json数据长度 ---->21195484
变种数据结构 压缩前json数据长度 ---->11404705
原始数据结构 Gzip压缩后json数据长度 ---->2982291
变种数据结构 Gzip压缩后json数据长度 ---->1377435
重复率为 0.66999966 压缩后:原始结构长度:变种数据结构=2.1651046
===================================================
原始数据结构 压缩前json数据长度 ---->21506771
变种数据结构 压缩前json数据长度 ---->11572016
原始数据结构 Gzip压缩后json数据长度 ---->3026339
变种数据结构 Gzip压缩后json数据长度 ---->1394127
重复率为 0.67999965 压缩后:原始结构长度:变种数据结构=2.170777
===================================================
原始数据结构 压缩前json数据长度 ---->21818058
变种数据结构 压缩前json数据长度 ---->11739327
原始数据结构 Gzip压缩后json数据长度 ---->3070877
变种数据结构 Gzip压缩后json数据长度 ---->1413357
重复率为 0.68999964 压缩后:原始结构长度:变种数据结构=2.172754
===================================================
原始数据结构 压缩前json数据长度 ---->22129345
变种数据结构 压缩前json数据长度 ---->11906638
原始数据结构 Gzip压缩后json数据长度 ---->3115375
变种数据结构 Gzip压缩后json数据长度 ---->1432763
重复率为 0.69999963 压缩后:原始结构长度:变种数据结构=2.1743827
===================================================
原始数据结构 压缩前json数据长度 ---->22440632
变种数据结构 压缩前json数据长度 ---->12073949
原始数据结构 Gzip压缩后json数据长度 ---->3159647
变种数据结构 Gzip压缩后json数据长度 ---->1450540
重复率为 0.7099996 压缩后:原始结构长度:变种数据结构=2.1782558
===================================================
原始数据结构 压缩前json数据长度 ---->22751919
变种数据结构 压缩前json数据长度 ---->12241260
原始数据结构 Gzip压缩后json数据长度 ---->3203965
变种数据结构 Gzip压缩后json数据长度 ---->1470894
重复率为 0.7199996 压缩后:原始结构长度:变种数据结构=2.1782434
===================================================
原始数据结构 压缩前json数据长度 ---->23063206
变种数据结构 压缩前json数据长度 ---->12408571
原始数据结构 Gzip压缩后json数据长度 ---->3248228
变种数据结构 Gzip压缩后json数据长度 ---->1493574
重复率为 0.7299996 压缩后:原始结构长度:变种数据结构=2.1748023
===================================================
原始数据结构 压缩前json数据长度 ---->23374493
变种数据结构 压缩前json数据长度 ---->12575882
原始数据结构 Gzip压缩后json数据长度 ---->3291666
变种数据结构 Gzip压缩后json数据长度 ---->1509693
重复率为 0.7399996 压缩后:原始结构长度:变种数据结构=2.1803546
===================================================
原始数据结构 压缩前json数据长度 ---->23685780
变种数据结构 压缩前json数据长度 ---->12743193
原始数据结构 Gzip压缩后json数据长度 ---->3335988
变种数据结构 Gzip压缩后json数据长度 ---->1529813
重复率为 0.7499996 压缩后:原始结构长度:变种数据结构=2.180651
===================================================
原始数据结构 压缩前json数据长度 ---->23997067
变种数据结构 压缩前json数据长度 ---->12910504
原始数据结构 Gzip压缩后json数据长度 ---->3380189
变种数据结构 Gzip压缩后json数据长度 ---->1553124
重复率为 0.7599996 压缩后:原始结构长度:变种数据结构=2.1763806
===================================================
原始数据结构 压缩前json数据长度 ---->24308354
变种数据结构 压缩前json数据长度 ---->13077815
原始数据结构 Gzip压缩后json数据长度 ---->3424182
变种数据结构 Gzip压缩后json数据长度 ---->1574941
重复率为 0.76999956 压缩后:原始结构长度:变种数据结构=2.1741652
===================================================
原始数据结构 压缩前json数据长度 ---->24619641
变种数据结构 压缩前json数据长度 ---->13245126
原始数据结构 Gzip压缩后json数据长度 ---->3468170
变种数据结构 Gzip压缩后json数据长度 ---->1593755
重复率为 0.77999955 压缩后:原始结构长度:变种数据结构=2.1760998
===================================================
原始数据结构 压缩前json数据长度 ---->24930928
变种数据结构 压缩前json数据长度 ---->13412437
原始数据结构 Gzip压缩后json数据长度 ---->3512665
变种数据结构 Gzip压缩后json数据长度 ---->1614833
重复率为 0.78999954 压缩后:原始结构长度:变种数据结构=2.1752498
===================================================
原始数据结构 压缩前json数据长度 ---->25242215
变种数据结构 压缩前json数据长度 ---->13579748
原始数据结构 Gzip压缩后json数据长度 ---->3557070
变种数据结构 Gzip压缩后json数据长度 ---->1636885
重复率为 0.79999954 压缩后:原始结构长度:变种数据结构=2.1730726
===================================================
原始数据结构 压缩前json数据长度 ---->25553502
变种数据结构 压缩前json数据长度 ---->13747059
原始数据结构 Gzip压缩后json数据长度 ---->3601118
变种数据结构 Gzip压缩后json数据长度 ---->1659303
重复率为 0.8099995 压缩后:原始结构长度:变种数据结构=2.1702595
===================================================
原始数据结构 压缩前json数据长度 ---->25864789
变种数据结构 压缩前json数据长度 ---->13914370
原始数据结构 Gzip压缩后json数据长度 ---->3645609
变种数据结构 Gzip压缩后json数据长度 ---->1676348
重复率为 0.8199995 压缩后:原始结构长度:变种数据结构=2.174733
===================================================
原始数据结构 压缩前json数据长度 ---->26176076
变种数据结构 压缩前json数据长度 ---->14081681
原始数据结构 Gzip压缩后json数据长度 ---->3689451
变种数据结构 Gzip压缩后json数据长度 ---->1700806
重复率为 0.8299995 压缩后:原始结构长度:变种数据结构=2.169237
===================================================
原始数据结构 压缩前json数据长度 ---->26487483
变种数据结构 压缩前json数据长度 ---->14249112
原始数据结构 Gzip压缩后json数据长度 ---->3733416
变种数据结构 Gzip压缩后json数据长度 ---->1725636
重复率为 0.8399995 压缩后:原始结构长度:变种数据结构=2.1635015
===================================================
原始数据结构 压缩前json数据长度 ---->26799070
变种数据结构 压缩前json数据长度 ---->14416723
原始数据结构 Gzip压缩后json数据长度 ---->3777020
变种数据结构 Gzip压缩后json数据长度 ---->1745732
重复率为 0.8499995 压缩后:原始结构长度:变种数据结构=2.1635737
===================================================
原始数据结构 压缩前json数据长度 ---->27110837
变种数据结构 压缩前json数据长度 ---->14584514
原始数据结构 Gzip压缩后json数据长度 ---->3820958
变种数据结构 Gzip压缩后json数据长度 ---->1768564
重复率为 0.8599995 压缩后:原始结构长度:变种数据结构=2.1604862
===================================================
原始数据结构 压缩前json数据长度 ---->27422784
变种数据结构 压缩前json数据长度 ---->14752485
原始数据结构 Gzip压缩后json数据长度 ---->3865001
变种数据结构 Gzip压缩后json数据长度 ---->1794227
重复率为 0.86999947 压缩后:原始结构长度:变种数据结构=2.1541317
===================================================
原始数据结构 压缩前json数据长度 ---->27734911
变种数据结构 压缩前json数据长度 ---->14920636
原始数据结构 Gzip压缩后json数据长度 ---->3909415
变种数据结构 Gzip压缩后json数据长度 ---->1812326
重复率为 0.87999946 压缩后:原始结构长度:变种数据结构=2.1571257
===================================================
原始数据结构 压缩前json数据长度 ---->28047218
变种数据结构 压缩前json数据长度 ---->15088967
原始数据结构 Gzip压缩后json数据长度 ---->3952788
变种数据结构 Gzip压缩后json数据长度 ---->1836339
重复率为 0.88999945 压缩后:原始结构长度:变种数据结构=2.152537
===================================================
原始数据结构 压缩前json数据长度 ---->28359705
变种数据结构 压缩前json数据长度 ---->15257478
原始数据结构 Gzip压缩后json数据长度 ---->3993938
变种数据结构 Gzip压缩后json数据长度 ---->1860461
重复率为 0.89999944 压缩后:原始结构长度:变种数据结构=2.1467464
===================================================
原始数据结构 压缩前json数据长度 ---->28672372
变种数据结构 压缩前json数据长度 ---->15426169
原始数据结构 Gzip压缩后json数据长度 ---->4034696
变种数据结构 Gzip压缩后json数据长度 ---->1886221
重复率为 0.90999943 压缩后:原始结构长度:变种数据结构=2.1390367
===================================================
原始数据结构 压缩前json数据长度 ---->28985219
变种数据结构 压缩前json数据长度 ---->15595040
原始数据结构 Gzip压缩后json数据长度 ---->4076048
变种数据结构 Gzip压缩后json数据长度 ---->1906665
重复率为 0.9199994 压缩后:原始结构长度:变种数据结构=2.1377892
===================================================
原始数据结构 压缩前json数据长度 ---->29298246
变种数据结构 压缩前json数据长度 ---->15764091
原始数据结构 Gzip压缩后json数据长度 ---->4116894
变种数据结构 Gzip压缩后json数据长度 ---->1935591
重复率为 0.9299994 压缩后:原始结构长度:变种数据结构=2.126944
===================================================
原始数据结构 压缩前json数据长度 ---->29611453
变种数据结构 压缩前json数据长度 ---->15933322
原始数据结构 Gzip压缩后json数据长度 ---->4158905
变种数据结构 Gzip压缩后json数据长度 ---->1958375
重复率为 0.9399994 压缩后:原始结构长度:变种数据结构=2.123651
===================================================
原始数据结构 压缩前json数据长度 ---->29924840
变种数据结构 压缩前json数据长度 ---->16102733
原始数据结构 Gzip压缩后json数据长度 ---->4201390
变种数据结构 Gzip压缩后json数据长度 ---->1981684
重复率为 0.9499994 压缩后:原始结构长度:变种数据结构=2.120111
===================================================
原始数据结构 压缩前json数据长度 ---->30238407
变种数据结构 压缩前json数据长度 ---->16272324
原始数据结构 Gzip压缩后json数据长度 ---->4243581
变种数据结构 Gzip压缩后json数据长度 ---->2009765
重复率为 0.9599994 压缩后:原始结构长度:变种数据结构=2.1114812
===================================================
原始数据结构 压缩前json数据长度 ---->30552154
变种数据结构 压缩前json数据长度 ---->16442095
原始数据结构 Gzip压缩后json数据长度 ---->4286753
变种数据结构 Gzip压缩后json数据长度 ---->2036300
重复率为 0.9699994 压缩后:原始结构长度:变种数据结构=2.1051676
===================================================
原始数据结构 压缩前json数据长度 ---->30866081
变种数据结构 压缩前json数据长度 ---->16612046
原始数据结构 Gzip压缩后json数据长度 ---->4330127
变种数据结构 Gzip压缩后json数据长度 ---->2056372
重复率为 0.97999936 压缩后:原始结构长度:变种数据结构=2.105712
===================================================
原始数据结构 压缩前json数据长度 ---->31180308
变种数据结构 压缩前json数据长度 ---->16782297
原始数据结构 Gzip压缩后json数据长度 ---->4373712
变种数据结构 Gzip压缩后json数据长度 ---->2078474
重复率为 0.98999935 压缩后:原始结构长度:变种数据结构=2.10429
===================================================
原始数据结构 压缩前json数据长度 ---->31494925
变种数据结构 压缩前json数据长度 ---->16952938
原始数据结构 Gzip压缩后json数据长度 ---->4417440
变种数据结构 Gzip压缩后json数据长度 ---->2107233
重复率为 0.99999934 压缩后:原始结构长度:变种数据结构=2.0963225
```
