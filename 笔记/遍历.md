### 小专栏
1. 数据库索引的原理
2. 针对你简历上写的、你曾经做过的、你最值得说道的一个项目或者是一个需求或者是一次优化不断追问
3. 针对自己曾经做过的某项工作进行充分整理，确保能非常清晰地说这项工作的前因后果，
   <br/>对实现过程中的技术选型、难点问题、解决方案、优化效果、深入改进等等了然于胸
4. LeetCode算法
5. 工程师的软素质
	1. 互联官公司4轮面试:前3轮是技术面,第4轮是HR面试.
	2. 1面,2面是专业知识和专业技能
	3. 3面重点是工程师的软素质
	4. HR面试软素质和文化匹配
	5. 软素质模型
		1. 核心是自我驱动力:自我设定成长目标+自律
		2. 好奇心和学习能力:不断紧跟新技术,必须不断奔跑,才能留在原地
			好奇心:
				1. Android:最新版本,包含哪些新特性,有哪些优秀的开源项目
				2. 热门技术领域:人工智能、深度学习、区块链、数字货币等
			学习能力:
				1. 有意愿,有行动,有结果
				2. 读了哪些书？读完后有什么收获？是开阔了视野、提高了认知、还是在工作中有实践？
				<br/>工作中遇到过哪些之前没遇到过的问题，是如何解决这些问题的
				3. 用Google查阅资料而不是度娘，尽量阅读官方文档而不是二手资料
		3. 沟通表达,技术规划,总结复盘
			技术规划遵循SMART原则:目标必须具体,可量化,可实现,和工作目的高度相关,有截止时间
		4. 美团点评的工程师文化
			完成胜过完美
			一定要代码能实现,少说,看结果
			不要重复自己,不断更新
			保持代码简洁,调用方便
			大道至简
6. Android所谓的知识体系
	1. Java 和 Anroid 基础
	2. 计算机网络
	3. 操作系统
	4. 设计模式
	5. 数据结构和算法
7. 拥有某个「能超过绝大部分人」的技能是非常必要
	阿里技术二面的时候，面试官一上来就说：“上一轮的面试官已经问了很多关于项目的东西了，你给我讲一下你觉得自己在 Android 中学的最好的东西吧。”
	面试中很多时候面试官关心的是你会什么，而不是纠结你不会什么。而且技术的深度也比广度要重要的多
8. 好的简历不仅是你得到面试机会的前提，更是后面拿下这场面试的基础
	1. 在面试中有两种最常见的形式，一是抛开简历问问题，二是盯着简历问问题
	2. 写简历的时候就应该一边写一边想我这样写那面试官肯定会问XX的，所以这就需要你对于简历中体现的项目的重点难点或知识点和闪光点进行一定的准备
9. 对市场不够了解，还是先降低难度从小厂面起吧，千万别上来就面大厂，很容易失败
10. 比如你工程化能力特别强 gradle 脚本玩的跟花似的 基本上肯定能进大公司
11. 记得不要把你最想去的简历最早投出去，等你面过几家有一定面试经验之后再投！
12. 很多人的基础真的很差
13. 回答算法问题，套路很重要：先有简单的版本，再进行优化
	衡量优劣的标准自然就是复杂度了，所以我们要能分析自己解法的复杂度。
	优化到什么程度？这需要结合自己的能力和留给写代码的时间，一定要写出一个完整可用的版本。
	如果还有时间，就可以继续和面试官探讨可能的优化思路了

	题目实在太难，完全没有思路怎么办？请教面试官呀！
	其实面试的过程是一个互动的过程，理想的面试过程是像同事之间讨论问题一样。
14. 






知识点总结. 2017 阿里、百度、美团、京东、今日头条、华为等秋季校招 Android 面经
	1. 头条很看中算法功底
	2. TCP三次握手四次挥手
	3. 为什么有三次握手，不是四次，或者两次
	4. Http头部有哪些，用过哪些
	5. Java看过源码吗，说说Collection的常用子接口和实现类，说说ArrayList和LinkedList区别
	6. AysncTask用过吗，各个函数分别在什么线程回调的
	7. 在子线程里怎么操作UI更新
	8. Handler工作原理
	9. 除了主线程之外其他的都要调用Looper.perpare()吗
	10. Fragment和Activity的生命周期之间的关系
	11. Service的生命周期，用过IntentService吗有什么区别
	12. 如何判断单链表有环，如何判断环的位置
	13. 手写二分查找
	14. 手写伪代码：给两个栈，要求实现队列
	15. Java的常用容器熟悉吗？知道Vector吗？说一下Hashmap和HashTable的区别
	16. 线程和进程之间的关系，做过多线程吗？在什么场景下应用
	17. 怎么保证线程同步
	18. Synchronize关键字的作用范围，volatile关键字的作用
	19. 死锁
	20. HashTable上，HashTable怎么保证线程同步，有没有更高效的可以保证线程同步的map
	21. Hashmap看过源码吗？了解底层实现吗？Hashmap怎么解决哈希冲突的问题？对Java8的改动有关注吗？了解Java8中对Hashmap有什么优化吗
	22. TCP三次握手过程？是哪一层协议？说一下OSI七层模型
	23. TCP和UDP的区别，知道分别有什么应用场景
	24. Activity的生命周期
	25. Activity的四种启动模式
	26. Android多进程开发
	27. 进程之间有哪些通讯方式
	28. Binder
	29. ListView怎么做优化
	30. 自定义View有哪些关键函数？分别有什么用
	31. 看过Java什么源码
	32. JVM的类加载
	33. 垃圾回收算法
	34. Java中的软引用，弱引用
	35. 设计模式
	36. Activity的生命周期，需要保存当前视图的状态应该怎么做
	37. Activity界面绘制的过程
	38. Looper，Message和MessageQueue关系
	39. Android四大组件，都用过吗
	40. 数据持久化怎么做
	41. Touch事件分发机制
	42. AIDL
	43. 手写代码：大整数加法
	44. Butterknife，Butterknife是什么阶段注解？注解的生命周期
	45. Okhttp做网络通讯，说一下Okhttp拦截器
	46. Http和Https区别，没有CA证书可以使用Https访问吗
	47. TCP在是哪一层的协议，三次握手过程
	48. 加密算法，说一说对称加密和非对称加密
	49. JVM吗，说说垃圾回收机制
	50. apk的编译过程吗，简单说了一下dex
	51. Collection的常用实现类，map的实现类
	52. Hashmap和Hashtable区别
	53. Hashmap的底层实现方式，如何解决哈希冲突，除了这种解决方式还有没有其他解决方式
	54. 很多网站像新浪微博网址都有短地址，如果让你实现怎么做
	55. 如何判断两个单链表相交
	56. 如何使用两个或多个栈模拟队列
	57. 手写代码：删除单链表倒数第x个结点
	57. 手写代码：z已知，在无序数组中找到两个数x和y，使x+y=z（使用哈希表以空间换时间）
	58. Handler的源码，当MessageQueue中没有Message会怎么处理
	59. 线程与进程，android跨进程通讯的方式
	60. 为什用Picasso，如果自己实现需要注意什么
	61. 图片三级缓存
	62. git rebase命令是做什么的
	63.	Java：
			多线程知识（锁、线程池）、
			内存模型、
			HashMap等；
		Android：
			线程间通信、
			多进程、
			View绘制、触摸事件传递等；
		算法：
			链表翻转、快速排序、二分查找、栈相关、int翻转、数组合并、LRUCache等，
		其他：MVP、单例、HTTPS等等
	64. Activity的生命周期
	65. Activity的任务栈
	66. Fragment的通讯，Fragment之间，Fragment和Activity
	67. 什么是Service，和Thread的区别
	68. Broadcast的作用和注册方式
	69. 什么是本地广播
	70. 什么是有序广播
	71. Android的异步处理方式有哪些
	72. AsycnTask、HandlerThread、IntentService源码
	73. ListView的缓存机制
	74. ANR是什么，怎么避免和排查
	75. OOM是什么，一般如果避免和解决
	76. 内存泄露是什么，常见的内存泄露有哪些
	77. 代码混淆
	78. Java IO
	78. 反射
	79. 操作系统原理
	80. https://blog.piasy.com/tags/#基础知识
	81. 抽象类的意义
		1. 封装子类中公共方法,提供1个供子类继承的模型
		2. 定义的抽象方法不同子类可以有不同的实现
		3. 将抽象类作为方法参数,可以减少方法数量,简化代码.
	82. 接口的意义
		1. 接口意义简单说:规范,扩展,回调,抽象类的好处接口都有
		2. 首先Java不允许多继承,1个类可以实现多个接口,可以看做是多继承的一种实现.
		3. 接口中可以定义不同抽象类的子类可能会用到的方法,通过实现多个接口灵活扩展子类实例

#### Java内部类
	1. 内部类分为: 成员内部类,局部内部类,匿名内部类,静态内部类
	2. 成员内部类
		1. 成员内部类可以随意访问外部类的包括private的属性及方法
		2. 成员内部类依附外部类而存在,如果要创建成员内部类的对象,前提是必须存在1个外部类对象.
		```
		public class T1 {
			private String s1 = "s1";
			private void s1(){
				System.out.println("T1.s1:"+s1);
			}
			private String s2 = "s2";
			private void s2(){
				System.out.println("T1.s2:"+s2);
			}
			
			@SuppressWarnings("unused")
			public static void main(String[] args) {
				//要创建1个成员内部类对象,必须先存在外部类对象,通过外部类对象进行创建
				T1 t1 = new T1();
		//		InClass1 inClass1 = t1.new InClass1();
				InClass1 inClass1 = t1.getInClass1Instance();
				inClass1.do1();
				inClass1.do2();
			}
			InClass1 getInClass1Instance(){
				return new InClass1();
			}
			class InClass1{
				public void do1(){
					//成员内部类可以随意访问外部类的属性及方法,包括private
					System.out.println("InClass1:do1;s1:"+s1);
					s1();
				}
				public void do2(){
					System.out.println("InClass1:do1;s2:"+s2);
					s2();
				}
			}
		}
		```
	3. 局部内部类
		1. 局部内部类是定义在1个方法或者作用域内的类.局部内部类的访问权限仅限于该方法或者作用域内.
		2. 局部内部类就像方法里的1个局部变量一样,不能用public、protected、private以及static修饰.
		3. 代码实例
		```
		public class T1 {
			public static void main(String[] args) {
				T1 t1 = new T1();
				t1.getWoman().p();
			}
			class People{
				public void p(){
					System.out.println("People:p");
				}
			}
			public People getWoman(){
				class Woman extends People{}
				return new Woman();
			}
		}
		```
	4. 匿名内部类
		1. 匿名内部类是平时用的最多的.设置事件监听.
		2. 使用匿名内部类能够在实现父类或者接口中的方法情况下同时产生1个相应的对象
		3. 代码实例
		```
		public class T1 {
			private String s1 = "s1";
			private void s1(){
				System.out.println("T1.s1:"+s1);
			}
			private String s2 = "s2";
			private void s2(){
				System.out.println("T1.s2:"+s2);
			}
			
			@SuppressWarnings("unused")
			public static void main(String[] args) {
				T1 t1 = new T1();
				t1.setListener(new Listener() {
					@Override
					public void do1() {
						System.out.println("Listener:do1");
					}
				});
			}
			
			interface Listener{
				void do1();
			}
			private void setListener(Listener l){
			}
		}
		```
	5. 静态内部类
		1. 静态内部类是不需要依赖于外部类的
		2. 代码实例
		```
		public class T1 {
			public static void main(String[] args) {
			}
			static int a = 100;
			int b = 200;
			static class sClass{
				void do1(){
					//静态内部类可以调用外部类的静态方法及静态变量
					//不能调用外部类的非static方法及变量
					main(null);
					a++;
					b++;//会报错.因为静态内部类不依赖外部类的实例化,非static变量是和外部类实例化后才会加载.
				}
			}
		}
		```
	6. 深入理解内部类
		1. 成员内部类
			在编译期,成员内部类会被单独编译为1个字节码文件.
			如上面的T1和InClass1,会被编译为 T1.class 和 T1&InClass1.class 两个class文件
			编译器会默认为成员内部类添加了一个指向外部类对象的引用
		2. 为何局部内部类和匿名内部类只能访问局部final变量?
			```
				class People{
					public void p(){
						System.out.println("People:p");
					}
				}
				public People getWoman(){
					final int a = 10;
					class Woman extends People{
						@Override
						public void p() {
							super.p();
							System.out.println("Woman a:"+a);
						}
						void pp(){
							System.out.println("pp");
						}
					}
					return new Woman();
				}
			```
			1. getWoman调用结束之后,a的生命周期就结束了,但是return new Woman()这个Woman实例的生命周期很可能没结束
			2. 为了防止在a的生命周期结束后继续使用a,Java将a进行了拷贝放在了匿名内部类/局部内部类内部
			3. 如果在a生命周期结束后,Woman实例继续对a进行变更,就会造成数据不一致.为了防止数据不一致,则限制局部变量只能为final,不可变更.