### 小专栏
1. 数据库索引的原理
2. 针对你简历上写的、你曾经做过的、你最值得说道的一个项目或者是一个需求或者是一次优化不断追问
3. 针对自己曾经做过的某项工作进行充分整理，确保能非常清晰地说这项工作的前因后果，
   <br/>对实现过程中的技术选型、难点问题、解决方案、优化效果、深入改进等等了然于胸
4. LeetCode算法
5. 工程师的软素质
	1. 互联官公司4轮面试:前3轮是技术面,第4轮是HR面试.
	2. 1面,2面是专业知识和专业技能
	3. 3面重点是工程师的软素质
	4. HR面试软素质和文化匹配
	5. 软素质模型
		1. 核心是自我驱动力:自我设定成长目标+自律
		2. 好奇心和学习能力:不断紧跟新技术,必须不断奔跑,才能留在原地
			好奇心:
				1. Android:最新版本,包含哪些新特性,有哪些优秀的开源项目
				2. 热门技术领域:人工智能、深度学习、区块链、数字货币等
			学习能力:
				1. 有意愿,有行动,有结果
				2. 读了哪些书？读完后有什么收获？是开阔了视野、提高了认知、还是在工作中有实践？
				<br/>工作中遇到过哪些之前没遇到过的问题，是如何解决这些问题的
				3. 用Google查阅资料而不是度娘，尽量阅读官方文档而不是二手资料
		3. 沟通表达,技术规划,总结复盘
			技术规划遵循SMART原则:目标必须具体,可量化,可实现,和工作目的高度相关,有截止时间
		4. 美团点评的工程师文化
			完成胜过完美
			一定要代码能实现,少说,看结果
			不要重复自己,不断更新
			保持代码简洁,调用方便
			大道至简
6. Android所谓的知识体系
	1. Java 和 Anroid 基础
	2. 计算机网络
	3. 操作系统
	4. 设计模式
	5. 数据结构和算法
7. 拥有某个「能超过绝大部分人」的技能是非常必要<br>
	阿里技术二面的时候，面试官一上来就说：“上一轮的面试官已经问了很多关于项目的东西了，你给我讲一下你觉得自己在 Android 中学的最好的东西吧。”<br>
	面试中很多时候面试官关心的是你会什么，而不是纠结你不会什么。而且技术的深度也比广度要重要的多
8. 好的简历不仅是你得到面试机会的前提，更是后面拿下这场面试的基础
	1. 在面试中有两种最常见的形式，一是抛开简历问问题，二是盯着简历问问题
	2. 写简历的时候就应该一边写一边想我这样写那面试官肯定会问XX的，所以这就需要你对于简历中体现的项目的重点难点或知识点和闪光点进行一定的准备
9. 对市场不够了解，还是先降低难度从小厂面起吧，千万别上来就面大厂，很容易失败
10. 比如你工程化能力特别强 gradle 脚本玩的跟花似的 基本上肯定能进大公司
11. 记得不要把你最想去的简历最早投出去，等你面过几家有一定面试经验之后再投！
12. 很多人的基础真的很差
13. 回答算法问题，套路很重要：先有简单的版本，再进行优化<br>
	衡量优劣的标准自然就是复杂度了，所以我们要能分析自己解法的复杂度。<br>
	优化到什么程度？这需要结合自己的能力和留给写代码的时间，一定要写出一个完整可用的版本。<br>
	如果还有时间，就可以继续和面试官探讨可能的优化思路了

	题目实在太难，完全没有思路怎么办？请教面试官呀！<br>
	其实面试的过程是一个互动的过程，理想的面试过程是像同事之间讨论问题一样。
14. 






知识点总结. 2017 阿里、百度、美团、京东、今日头条、华为等秋季校招 Android 面经
	1. 头条很看中算法功底
	2. TCP三次握手四次挥手
	3. 为什么有三次握手，不是四次，或者两次
	4. Http头部有哪些，用过哪些
	5. Java看过源码吗，说说Collection的常用子接口和实现类，说说ArrayList和LinkedList区别
	6. AysncTask用过吗，各个函数分别在什么线程回调的
	7. 在子线程里怎么操作UI更新
	8. Handler工作原理
	9. 除了主线程之外其他的都要调用Looper.perpare()吗
	10. Fragment和Activity的生命周期之间的关系
	11. Service的生命周期，用过IntentService吗有什么区别
	12. 如何判断单链表有环，如何判断环的位置
	13. 手写二分查找
	14. 手写伪代码：给两个栈，要求实现队列
	15. Java的常用容器熟悉吗？知道Vector吗？说一下Hashmap和HashTable的区别
	16. 线程和进程之间的关系，做过多线程吗？在什么场景下应用
	17. 怎么保证线程同步
	18. Synchronize关键字的作用范围，volatile关键字的作用
	19. 死锁
	20. HashTable上，HashTable怎么保证线程同步，有没有更高效的可以保证线程同步的map
	21. Hashmap看过源码吗？了解底层实现吗？Hashmap怎么解决哈希冲突的问题？对Java8的改动有关注吗？了解Java8中对Hashmap有什么优化吗
	22. TCP三次握手过程？是哪一层协议？说一下OSI七层模型
	23. TCP和UDP的区别，知道分别有什么应用场景
	24. Activity的生命周期
	25. Activity的四种启动模式
	26. Android多进程开发
	27. 进程之间有哪些通讯方式
	28. Binder
	29. ListView怎么做优化
	30. 自定义View有哪些关键函数？分别有什么用
	31. 看过Java什么源码
	32. JVM的类加载
	33. 垃圾回收算法
	34. Java中的软引用，弱引用
	35. 设计模式
	36. Activity的生命周期，需要保存当前视图的状态应该怎么做
	37. Activity界面绘制的过程
	38. Looper，Message和MessageQueue关系
	39. Android四大组件，都用过吗
	40. 数据持久化怎么做
	41. Touch事件分发机制
	42. AIDL
	43. 手写代码：大整数加法
	44. Butterknife，Butterknife是什么阶段注解？注解的生命周期
	45. Okhttp做网络通讯，说一下Okhttp拦截器
	46. Http和Https区别，没有CA证书可以使用Https访问吗
	47. TCP在是哪一层的协议，三次握手过程
	48. 加密算法，说一说对称加密和非对称加密
	49. JVM吗，说说垃圾回收机制
	50. apk的编译过程吗，简单说了一下dex
	51. Collection的常用实现类，map的实现类
	52. Hashmap和Hashtable区别
	53. Hashmap的底层实现方式，如何解决哈希冲突，除了这种解决方式还有没有其他解决方式
	54. 很多网站像新浪微博网址都有短地址，如果让你实现怎么做
	55. 如何判断两个单链表相交
	56. 如何使用两个或多个栈模拟队列
	57. 手写代码：删除单链表倒数第x个结点
	57. 手写代码：z已知，在无序数组中找到两个数x和y，使x+y=z（使用哈希表以空间换时间）
	58. Handler的源码，当MessageQueue中没有Message会怎么处理
	59. 线程与进程，android跨进程通讯的方式
	60. 为什用Picasso，如果自己实现需要注意什么
	61. 图片三级缓存
	62. git rebase命令是做什么的
	63.	Java：
			多线程知识（锁、线程池）、
			内存模型、
			HashMap等；
		Android：
			线程间通信、
			多进程、
			View绘制、触摸事件传递等；
		算法：
			链表翻转、快速排序、二分查找、栈相关、int翻转、数组合并、LRUCache等，
		其他：MVP、单例、HTTPS等等
	64. Activity的生命周期
	65. Activity的任务栈
	66. Fragment的通讯，Fragment之间，Fragment和Activity
	67. 什么是Service，和Thread的区别
	68. Broadcast的作用和注册方式
	69. 什么是本地广播
	70. 什么是有序广播
	71. Android的异步处理方式有哪些
	72. AsycnTask、HandlerThread、IntentService源码
	73. ListView的缓存机制
	74. ANR是什么，怎么避免和排查
	75. OOM是什么，一般如果避免和解决
	76. 内存泄露是什么，常见的内存泄露有哪些
	77. 代码混淆
	78. Java IO
	78. 反射
	79. 操作系统原理
	80. https://blog.piasy.com/tags/#基础知识
	81. 抽象类的意义
		1. 封装子类中公共方法,提供1个供子类继承的模型
		2. 定义的抽象方法不同子类可以有不同的实现
		3. 将抽象类作为方法参数,可以减少方法数量,简化代码.
	82. 接口的意义
		1. 接口意义简单说:规范,扩展,回调,抽象类的好处接口都有
		2. 首先Java不允许多继承,1个类可以实现多个接口,可以看做是多继承的一种实现.
		3. 接口中可以定义不同抽象类的子类可能会用到的方法,通过实现多个接口灵活扩展子类实例
	83. Java 虚拟机的特性
	84. 哪些情况下的对象会被垃圾回收机制处理掉
	85. 
	86. 

#### Java内部类
1. 内部类分为: 成员内部类,局部内部类,匿名内部类,静态内部类
2. 成员内部类
    1. 成员内部类可以随意访问外部类的包括private的属性及方法
    2. 成员内部类依附外部类而存在,如果要创建成员内部类的对象,前提是必须存在1个外部类对象.
		```
		public class T1 {
			private String s1 = "s1";
			private void s1(){
				System.out.println("T1.s1:"+s1);
			}
			private String s2 = "s2";
			private void s2(){
				System.out.println("T1.s2:"+s2);
			}
			
			@SuppressWarnings("unused")
			public static void main(String[] args) {
				//要创建1个成员内部类对象,必须先存在外部类对象,通过外部类对象进行创建
				T1 t1 = new T1();
		//		InClass1 inClass1 = t1.new InClass1();
				InClass1 inClass1 = t1.getInClass1Instance();
				inClass1.do1();
				inClass1.do2();
			}
			InClass1 getInClass1Instance(){
				return new InClass1();
			}
			class InClass1{
				public void do1(){
					//成员内部类可以随意访问外部类的属性及方法,包括private
					System.out.println("InClass1:do1;s1:"+s1);
					s1();
				}
				public void do2(){
					System.out.println("InClass1:do1;s2:"+s2);
					s2();
				}
			}
		}
		```
    3. 局部内部类
		1. 局部内部类是定义在1个方法或者作用域内的类.局部内部类的访问权限仅限于该方法或者作用域内.
		2. 局部内部类就像方法里的1个局部变量一样,不能用public、protected、private以及static修饰.
		3. 代码实例
		```
		public class T1 {
			public static void main(String[] args) {
				T1 t1 = new T1();
				t1.getWoman().p();
			}
			class People{
				public void p(){
					System.out.println("People:p");
				}
			}
			public People getWoman(){
				class Woman extends People{}
				return new Woman();
			}
		}
		```
	4. 匿名内部类
		1. 匿名内部类是平时用的最多的.设置事件监听.
		2. 使用匿名内部类能够在实现父类或者接口中的方法情况下同时产生1个相应的对象
		3. 代码实例
		```
		public class T1 {
			private String s1 = "s1";
			private void s1(){
				System.out.println("T1.s1:"+s1);
			}
			private String s2 = "s2";
			private void s2(){
				System.out.println("T1.s2:"+s2);
			}
			
			@SuppressWarnings("unused")
			public static void main(String[] args) {
				T1 t1 = new T1();
				t1.setListener(new Listener() {
					@Override
					public void do1() {
						System.out.println("Listener:do1");
					}
				});
			}
			
			interface Listener{
				void do1();
			}
			private void setListener(Listener l){
			}
		}
		```
	5. 静态内部类
		1. 静态内部类是不需要依赖于外部类的
		2. 代码实例
		```
		public class T1 {
			public static void main(String[] args) {
			}
			static int a = 100;
			int b = 200;
			static class sClass{
				void do1(){
					//静态内部类可以调用外部类的静态方法及静态变量
					//不能调用外部类的非static方法及变量
					main(null);
					a++;
					b++;//会报错.因为静态内部类不依赖外部类的实例化,非static变量是和外部类实例化后才会加载.
				}
			}
		}
		```
	6. 深入理解内部类
        1. 成员内部类
			在编译期,成员内部类会被单独编译为1个字节码文件.<br>
			如上面的T1和InClass1,会被编译为 T1.class 和 T1&InClass1.class 两个class文件<br/>
			编译器会默认为成员内部类添加了一个指向外部类对象的引用
			当成员内部类和外部类拥有相同名称的成员变量，在内部类中调用访问，默认情况下访问的是成员内部类的成员变量;<br>
			要访问外部类的成员变量,要使用 外部类.this.成员变量 的形式
            ```
            public class JavaTest1 {
            	public static void main(String[] args) {
            		JavaTest1 t = new JavaTest1();
            		InClass c = t.new InClass();
            		c.p();
            	}
            	private int a = 300;
            	class InClass{
            		private int a = 100;
            		public void p(){
            			int a = 200;
            			System.out.println("a:"+a);
            			System.out.println("this.a:"+this.a);
            			System.out.println("JavaTest1.this.a:"+JavaTest1.this.a);
            		}
            	}
            }
            
            a:200
            this.a:100
            JavaTest1.this.a:300
            ```
		2. 为何局部内部类和匿名内部类只能访问局部final变量?
            ```
            class People{
            	public void p(){
            		System.out.println("People:p");
            	}
            }
            public People getWoman(){
            	final int a = 10;
            	class Woman extends People{
            		@Override
            		public void p() {
            			super.p();
            			System.out.println("Woman a:"+a);
            		}
            		void pp(){
            			System.out.println("pp");
            		}
            	}
            	return new Woman();
            }
            ```
            1. getWoman调用结束之后,a的生命周期就结束了,但是return new Woman()这个Woman实例的生命周期很可能没结束
            2. 为了防止在a的生命周期结束后继续使用a,Java将a进行了拷贝放在了匿名内部类/局部内部类内部
            3. 如果在a生命周期结束后,Woman实例继续对a进行变更,就会造成数据不一致.为了防止数据不一致,则限制局部变量只能为final,不可变更.
        3. 为何成员内部类不能有静态方法和静态变量?
            1. 成员内部类,本质上相当于外部类的一个非静态变量,它的加载依赖于外部类的实例化;
            2. 而java虚拟机要求静态成员的加载不能依赖类的实例化;
			两者是矛盾的,因而不能包含静态成员.

#### string-stringbuffer-stringbuilder区别
1. String:字符串常量
2. StringBuffer:线程安全的字符串变量
3. StringBuilder:非线程安全的字符串变量
	1. String是不可变对象.每次对String进行修改都相当于生成了一个新的String对象,然后将原始字符串的指针指向新String对象.<br>
	所以对于需要经常改变的字符串,每次改变都会生成新的对象,频繁创建新对象会影响性能.当内存中无引用对象多了就会触发JVM的GC.
	2. StringBuffer是线程安全的可变字符串序列,每次改变都是对StringBuffer实例本身进行变更,不会创建新的对象,性能远远好于String
	3. StringBuilder是非线程安全的可变字符串序列,在不考虑线程安全情况下推进使用StringBuilder,性能比StringBuffer更好.
	4. 代码实例:由此可见,StringBuilder和StringBuffer的性能远好于String. StringBuilder>StringBuffer>String
	```
	public class JavaTest1 {
		public static void main(String[] args) {
			String s = "";
			StringBuffer buffer = new StringBuffer();
			StringBuilder builder = new StringBuilder();
			long start0 = System.currentTimeMillis();
			//String 10万条
			for(int i = 0; i< 100000; i++){
				s+="1";
			}
			long end0 = System.currentTimeMillis();
			long start1 = System.currentTimeMillis();
			//StringBuffer 和 StringBuilder 1000万条
			for(int i = 0; i< 10000000; i++){
				buffer.append("1");
			}
			long end1 = System.currentTimeMillis();
			long start2 = System.currentTimeMillis();
			for(int i = 0; i< 10000000; i++){
				builder.append("1");
			}
			long end2 = System.currentTimeMillis();
			System.out.println("耗时统计:String="+(end0-start0)+"ms;StringBuffer="+(end1-start1)+"ms;StringBuilder="+(end2-start2)+"ms");
		}
	
	耗时统计:String=3804ms;StringBuffer=281ms;StringBuilder=78ms
	```

#### 什么导致线程阻塞
1. java提供了以下方法实现线程阻塞:sleep,suspend+resume,yield,wait+notify+notifyAll
2. sleep:使线程在指定毫秒值内进入阻塞状态,不能得到CPU时间.指定时间已过,重新进入可执行状态
3. suspend+resume: suspend让线程进入阻塞状态,且不会自动恢复,必须其对应的resume被调用,线程才能重新进入可执行状态
4. yield:yield使当前线程放弃当前分得的CPU时间,使得调度程序认为当前线程已经执行了足够时间从而转到另1个线程.<br>
		yield执行后当前线程依然处于可执行状态,不会阻塞,随时可以再次获得CPU时间
5. wait+notify
		wait使线程进入阻塞状态,并释放已经获得的锁;notify使线程解除阻塞状态.
6. wait+notify+notifyAll和前面几个方法的区别
    1. wait,notify,notifyAll是隶属于Object的,而前面方法则隶属于Thread.
    2. 前面的方法可以在任意位置调用,而wait,notify,notifyAll则必须在synchronized方法或方法块中调用,原因:
        1. wait不仅会阻塞当前线程,还会释放已经获得的锁.只有在synchronized中当前线程才能获得锁,才有锁可以释放;
        2. 如果在非synchronized方法或代码块中调用wait,notify,notifyAll,就会报异常:java.lang.IllegalMonitorStateException
            ```
            public class T2 {
            	public static void main(String[] args) {
            		Object o = new Object();
            		synchronized (o) {
            			try {
            			        //wait,notify,notifyAll必须在同步代码块
            			        //或同步方法中调用
            //				o.wait();
            				o.wait(1000);
            				o.notify();
            			} catch (InterruptedException e) {
            				// TODO Auto-generated catch block
            				e.printStackTrace();
            			}
            		}
            		//在同步块以外调用触发
            		//java.lang.IllegalMonitorStateException
            		o.notifyAll();
            	}
            }
            ```
7. notify及notifyAll
    1. Object o.notify调用后,比如有多个线程调用过 o.wait,则从这几个被阻塞的线程中随机选1个,解除其阻塞状态.
    2. Object o.notifyAll调用后,比如有多个线程调用过 o.wait,则将这几个被阻塞的线程,全部解除其阻塞状态.
    3. 解除阻塞状态,线程也不一定是可运行状态,只有获得锁,才是可运行状态.

#### Java中线程的状态转换
![线程状态图](https://user-gold-cdn.xitu.io/2018/8/7/165126c29d9b29af?w=968&h=680&f=jpeg&s=91092)
线程包含以下状态: 新建,可运行,运行,阻塞,死亡
1. 新建:新创建了一个线程对象
2. 可运行:Thread被创建后,其他线程调用了其start方法,则Thread进入可运行状态.<br>,等待被操作系统选中,获取CPU的使用权
3. 运行:可运行状态的Thread被操作系统选中,获取了CPU时间片,执行代码
4. 阻塞:运行状态的Thread放弃了CPU的使用权,让出了CPU时间片,暂时停止运行<br>z直到该线程再次进入可运行状态,才有机会重新获取CPU使用权进入运行状态.<br>
阻塞情况分3种:
    1. 运行状态的Thread执行Object o.wait,JVM会把线程放入等待队列中
    2. 运行状态的Thread执行synchronized(Object o)时,若该对象的同步锁已被其他线程占用,JVM会将该线程放入锁池中
    3. 运行状态的Thread执行Thread.sleep,Thread.join,或发出了IO请求,则JVM会将其设置为阻塞状态.当sleep超时,join等待的线程终止或超时,或IO执行完毕,该线程会重新进入 可运行状态
5. 死亡:线程的run方法结束,或因异常退出了run方法,则该线程死亡,生命周期结束.

#### synchronized和Lock
- **synchronized**
    - synchronized是Java中的关键字,利用锁机制来实现同步
    - synchronized使用位置
        - 修饰代码块
            - 1:synchronized(this|Object){}     修饰对象获取的是对象锁
            - 2:synchronized(类.class){}        修饰类.class获取的是类锁
        - 修饰方法
            - 3:synchronized static method(){}      修饰静态方法获取的是类锁
            - 4:synchronized method(){}             修饰非静态方法获取的是对象锁
    - 每个对象有1个对象锁,1个类下所有对象共用1个类锁
    - 线程A获取了类锁,在A释放类锁前,其他线程无法获取到类锁
    - 同1个类的多个对象,其多个对象锁彼此独立
        - 线程A获取了S1的对象锁,在A释放对象锁之前,其他线程无妨获取到S1的对象锁
        - 线程A获取了S1的对象锁,不影响其他线程获取S2,S3---的对象锁
    - 对象锁和类锁彼此独立
        - 线程A获取了S1的对象锁,可以同时获取S1所属类的类锁
        - 线程A获取了S1的对象锁,线程B可以获取S1所属类的类锁
- **Lock**
    - 使用Lock可以更灵活/更繁琐的解决线程安全/数据同步问题
    - 我们可以使用ReentrantLock和ReentrantReadWriteLock
    - Lock需要 手动加锁,共享数据访问放到try块内,并在finally中手动释放锁
    - ReentrantLock实例
        ```
        public class T2 {
        	public static void main(String[] args) {
        		T2 t = new T2();
        		t.t();
        	}
        	private void t(){
        		new Thread(new Runnable() {
        			@Override
        			public void run() {
        				execute(true);
        			}
        		}).start();
        		new Thread(new Runnable() {
        			@Override
        			public void run() {
        				execute(false);
        			}
        		}).start();
        	}
        	
        	private int a = 0;
        	private ReentrantLock lock = new ReentrantLock();
        	private void execute(boolean increase){
        		//手动加锁
        		lock.lock();
        		try {
        		    //共享数据访问包在try块中
        			for(int i = 0; i < 1000; i++){
        				if(increase){
        					a++;
        				}else{
        					a--;
        				}
        				System.out.println("a:"+a);
        			}
        		} catch (Exception e) {
        		} finally{
        			//finally中手动释放锁
        			lock.unlock();
        		}
        	}
        }
        
        a:1
        a:2
        a:3
        a:4
        a:5
        a:6
        ----
        a:1000
        a:999
        a:998
        a:997
        a:996
        a:995
        ----
        a:2
        a:1
        a:0
        ```
    - ReadWriteLock实例:读取共享数据的方法中使用readLock,设置共享数据的方法中使用writeLock
        ```
        public class T2 {
        	public static void main(String[] args) {
        		T2 t = new T2();
        		t.t();
        	}
        	
        	private String s = "s";
        	private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
        	private Lock read = readWriteLock.readLock();
        	private Lock write = readWriteLock.writeLock();
        	public String getS() {
        		read.lock();
        		try {
        			Thread.sleep(20);
        			return s;
        		} catch (Exception e) {
        			return null;
        		} finally{
        			read.unlock();
        		}
        	}
        	public void setS(String s) {
        		write.lock();
        		try {
        			Thread.sleep(50);
        			this.s = s;
        		} catch (Exception e) {
        		} finally{
        			write.unlock();
        		}
        	}
        	private void t(){
        		new Thread(new Runnable() {
        			@Override
        			public void run() {
        				exe(false);
        			}
        		}).start();
        		new Thread(new Runnable() {
        			@Override
        			public void run() {
        				exe(false);
        			}
        		}).start();
        		new Thread(new Runnable() {
        			@Override
        			public void run() {
        				exe(true);
        			}
        		}).start();
        		new Thread(new Runnable() {
        			@Override
        			public void run() {
        				exe(false);
        			}
        		}).start();
        		new Thread(new Runnable() {
        			@Override
        			public void run() {
        				exe(false);
        			}
        		}).start();
        		new Thread(new Runnable() {
        			@Override
        			public void run() {
        				exe(false);
        			}
        		}).start();
        	}
        	private void exe(boolean set){
        		for(int i = 0; i< 100; i++){
        			if(set){
        				setS("滚你妹:"+i);
        				System.out.println("ThreadId:"+Thread.currentThread().getId()+";setS:"+s);
        			}else{
        				String s = getS();
        				System.out.println("ThreadId:"+Thread.currentThread().getId()+";getS:"+s);
        			}
        		}
        	}
        }
        ThreadId:9;getS:s
        ThreadId:10;getS:s
        ThreadId:11;setS:滚你妹:0
        ThreadId:13;getS:滚你妹:0
        ThreadId:9;getS:滚你妹:0
        ThreadId:12;getS:滚你妹:0
        ThreadId:14;getS:滚你妹:0
        ThreadId:10;getS:滚你妹:0
        ThreadId:11;setS:滚你妹:1
        ThreadId:14;getS:滚你妹:1
        ThreadId:12;getS:滚你妹:1
        ThreadId:9;getS:滚你妹:1
        ThreadId:13;getS:滚你妹:1
        ThreadId:10;getS:滚你妹:1
        ThreadId:11;setS:滚你妹:2
        ThreadId:14;getS:滚你妹:2
        ThreadId:9;getS:滚你妹:2
        ThreadId:13;getS:滚你妹:2
        ThreadId:12;getS:滚你妹:2
        ThreadId:10;getS:滚你妹:2
        ThreadId:11;setS:滚你妹:3
        ThreadId:12;getS:滚你妹:3
        ThreadId:9;getS:滚你妹:3
        ThreadId:13;getS:滚你妹:3
        ThreadId:10;getS:滚你妹:3
        ThreadId:14;getS:滚你妹:3
        ThreadId:11;setS:滚你妹:4
        ThreadId:14;getS:滚你妹:4
        ThreadId:9;getS:滚你妹:4
        ThreadId:12;getS:滚你妹:4
        ThreadId:13;getS:滚你妹:4
        ThreadId:10;getS:滚你妹:4
        ```

#### HashMap,SparseArray,ArrayMap区别及性能分析
HashMap结构:
![](https://user-gold-cdn.xitu.io/2018/8/7/16513806a20e95ff?w=474&h=373&f=png&s=24855)
SparseArray结构:
![](https://user-gold-cdn.xitu.io/2018/8/7/16513813d5131851?w=311&h=245&f=png&s=14121)
ArrayMap结构:
![](https://user-gold-cdn.xitu.io/2018/8/7/1651380bc6dc5137?w=366&h=394&f=png&s=23189)
1. 首先3者的结构不同.HashMap是使用数组+单链表的形式存储数据;SparseArray和ArrayMap都是采用2个数组形式存储数据;
    - 因为hash的值不是连续的，所以hashmap实际需要占用的大小会比它实际能装的item的容量要大;
    - ArrayMap使用int[] mHashes来连续存储Key的hash值,查询时候采用二分查找获取指定Key的index;
    - SparseArray相对于ArrayMap仅仅支持key类型为int(Integer都不行)的情况,内部结构和ArrayMap类似;
    - 数据结构的不同导致SparseArray和ArrayMap更加节省内存.
2. 有人做过3者的性能实验
    - key为int情况下,数据量1000以内,SparseArray相比较HashMap内存节省30%;<br>
    ArrayMap只能节省10%
    - 查询时间性能上,ArrayMap是最差的;对于HashMap和SparseArray,如果HashMap使用map.get(Integer)则性能高于SparseArray,如果使用map.get(int),因为涉及自动装箱过程,性能低于SparseArray.
    - 根据上面实验,ArrayMap就是垃圾,用不着.SparseArray几乎也用不着.很少会用到key类型为int的情况.如果遇到,且存储数量低于1000,可以使用.
