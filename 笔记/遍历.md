### 小专栏
#### 1.数据库索引的原理
#### 1.针对你简历上写的、你曾经做过的、你最值得说道的一个项目或者是一个需求或者是一次优化不断追问
#### 1.针对自己曾经做过的某项工作进行充分整理，确保能非常清晰地说这项工作的前因后果，
   <br/>对实现过程中的技术选型、难点问题、解决方案、优化效果、深入改进等等了然于胸
#### 1.LeetCode算法
#### 1.工程师的软素质
1. 互联官公司4轮面试:前3轮是技术面,第4轮是HR面试.
2. 1面,2面是专业知识和专业技能
3. 3面重点是工程师的软素质
4. HR面试软素质和文化匹配
5. 软素质模型
	1. 核心是自我驱动力:自我设定成长目标+自律
	2. 好奇心和学习能力:不断紧跟新技术,必须不断奔跑,才能留在原地
        - 好奇心:
			1. Android:最新版本,包含哪些新特性,有哪些优秀的开源项目
			2. 热门技术领域:人工智能、深度学习、区块链、数字货币等
        - 学习能力:
			1. 有意愿,有行动,有结果
			2. 读了哪些书？读完后有什么收获？是开阔了视野、提高了认知、还是在工作中有实践？
			<br/>工作中遇到过哪些之前没遇到过的问题，是如何解决这些问题的
			3. 用Google查阅资料而不是度娘，尽量阅读官方文档而不是二手资料
	3. 沟通表达,技术规划,总结复盘
        - 技术规划遵循SMART原则:目标必须具体,可量化,可实现,和工作目的高度相关,有截止时间
	4. 美团点评的工程师文化
        - 完成胜过完美
        - 一定要代码能实现,少说,看结果
        - 不要重复自己,不断更新
        - 保持代码简洁,调用方便
        - 大道至简
#### 1.Android所谓的知识体系
	1. Java 和 Anroid 基础
	2. 计算机网络
	3. 操作系统
	4. 设计模式
	5. 数据结构和算法
#### 1.拥有某个「能超过绝大部分人」的技能是非常必要<br>
	阿里技术二面的时候，面试官一上来就说：“上一轮的面试官已经问了很多关于项目的东西了，你给我讲一下你觉得自己在 Android 中学的最好的东西吧。”<br>
	面试中很多时候面试官关心的是你会什么，而不是纠结你不会什么。而且技术的深度也比广度要重要的多
#### 1.好的简历不仅是你得到面试机会的前提，更是后面拿下这场面试的基础
	1. 在面试中有两种最常见的形式，一是抛开简历问问题，二是盯着简历问问题
	2. 写简历的时候就应该一边写一边想我这样写那面试官肯定会问XX的，所以这就需要你对于简历中体现的项目的重点难点或知识点和闪光点进行一定的准备
#### 1.对市场不够了解，还是先降低难度从小厂面起吧，千万别上来就面大厂，很容易失败
#### 1.比如你工程化能力特别强 gradle 脚本玩的跟花似的 基本上肯定能进大公司
#### 1.记得不要把你最想去的简历最早投出去，等你面过几家有一定面试经验之后再投！
#### 1.很多人的基础真的很差
#### 1.回答算法问题，套路很重要：先有简单的版本，再进行优化<br>
	衡量优劣的标准自然就是复杂度了，所以我们要能分析自己解法的复杂度。<br>
	优化到什么程度？这需要结合自己的能力和留给写代码的时间，一定要写出一个完整可用的版本。<br>
	如果还有时间，就可以继续和面试官探讨可能的优化思路了

	题目实在太难，完全没有思路怎么办？请教面试官呀！<br>
	其实面试的过程是一个互动的过程，理想的面试过程是像同事之间讨论问题一样。
14. 






知识点总结. 2017 阿里、百度、美团、京东、今日头条、华为等秋季校招 Android 面经
	1. 头条很看中算法功底
	2. TCP三次握手四次挥手
	3. 为什么有三次握手，不是四次，或者两次
	4. Http头部有哪些，用过哪些
	5. Java看过源码吗，说说Collection的常用子接口和实现类，说说ArrayList和LinkedList区别
	6. AysncTask用过吗，各个函数分别在什么线程回调的
	7. 在子线程里怎么操作UI更新
	8. Handler工作原理
	9. 除了主线程之外其他的都要调用Looper.perpare()吗
	10. Fragment和Activity的生命周期之间的关系
	11. Service的生命周期，用过IntentService吗有什么区别
	12. 如何判断单链表有环，如何判断环的位置
	13. 手写二分查找
	14. 手写伪代码：给两个栈，要求实现队列
	15. Java的常用容器熟悉吗？知道Vector吗？说一下Hashmap和HashTable的区别
	16. 线程和进程之间的关系，做过多线程吗？在什么场景下应用
	17. 怎么保证线程同步
	18. Synchronize关键字的作用范围，volatile关键字的作用
	19. 死锁
	20. HashTable上，HashTable怎么保证线程同步，有没有更高效的可以保证线程同步的map
	21. Hashmap看过源码吗？了解底层实现吗？Hashmap怎么解决哈希冲突的问题？对Java8的改动有关注吗？了解Java8中对Hashmap有什么优化吗
	22. TCP三次握手过程？是哪一层协议？说一下OSI七层模型
	23. TCP和UDP的区别，知道分别有什么应用场景
	24. Activity的生命周期
	25. Activity的四种启动模式
	26. Android多进程开发
	27. 进程之间有哪些通讯方式
	28. Binder
	29. ListView怎么做优化
	30. 自定义View有哪些关键函数？分别有什么用
	31. 看过Java什么源码
	32. JVM的类加载
	33. 垃圾回收算法
	34. Java中的软引用，弱引用
	35. 设计模式
	36. Activity的生命周期，需要保存当前视图的状态应该怎么做
	37. Activity界面绘制的过程
	38. Looper，Message和MessageQueue关系
	39. Android四大组件，都用过吗
	40. 数据持久化怎么做
	41. Touch事件分发机制
	42. AIDL
	43. 手写代码：大整数加法
	44. Butterknife，Butterknife是什么阶段注解？注解的生命周期
	45. Okhttp做网络通讯，说一下Okhttp拦截器
	46. Http和Https区别，没有CA证书可以使用Https访问吗
	47. TCP在是哪一层的协议，三次握手过程
	48. 加密算法，说一说对称加密和非对称加密
	49. JVM吗，说说垃圾回收机制
	50. apk的编译过程吗，简单说了一下dex
	51. Collection的常用实现类，map的实现类
	52. Hashmap和Hashtable区别
	53. Hashmap的底层实现方式，如何解决哈希冲突，除了这种解决方式还有没有其他解决方式
	54. 很多网站像新浪微博网址都有短地址，如果让你实现怎么做
	55. 如何判断两个单链表相交
	56. 如何使用两个或多个栈模拟队列
	57. 手写代码：删除单链表倒数第x个结点
	57. 手写代码：z已知，在无序数组中找到两个数x和y，使x+y=z（使用哈希表以空间换时间）
	58. Handler的源码，当MessageQueue中没有Message会怎么处理
	59. 线程与进程，android跨进程通讯的方式
	60. 为什用Picasso，如果自己实现需要注意什么
	61. 图片三级缓存
	62. git rebase命令是做什么的
	63.	Java：
			多线程知识（锁、线程池）、
			内存模型、
			HashMap等；
		Android：
			线程间通信、
			多进程、
			View绘制、触摸事件传递等；
		算法：
			链表翻转、快速排序、二分查找、栈相关、int翻转、数组合并、LRUCache等，
		其他：MVP、单例、HTTPS等等
	64. Activity的生命周期
	65. Activity的任务栈
	66. Fragment的通讯，Fragment之间，Fragment和Activity
	67. 什么是Service，和Thread的区别
	68. Broadcast的作用和注册方式
	69. 什么是本地广播
	70. 什么是有序广播
	71. Android的异步处理方式有哪些
	72. AsycnTask、HandlerThread、IntentService源码
	73. ListView的缓存机制
	74. ANR是什么，怎么避免和排查
	75. OOM是什么，一般如果避免和解决
	76. 内存泄露是什么，常见的内存泄露有哪些
	77. 代码混淆
	78. Java IO
	78. 反射
	79. 操作系统原理
	80. https://blog.piasy.com/tags/#基础知识
	81. 抽象类的意义
		1. 封装子类中公共方法,提供1个供子类继承的模型
		2. 定义的抽象方法不同子类可以有不同的实现
		3. 将抽象类作为方法参数,可以减少方法数量,简化代码.
	82. 接口的意义
		1. 接口意义简单说:规范,扩展,回调,抽象类的好处接口都有
		2. 首先Java不允许多继承,1个类可以实现多个接口,可以看做是多继承的一种实现.
		3. 接口中可以定义不同抽象类的子类可能会用到的方法,通过实现多个接口灵活扩展子类实例
	83. Java 虚拟机的特性
	84. 哪些情况下的对象会被垃圾回收机制处理掉
	85. 
	86. 

#### 1.Java内部类
1. 内部类分为: 成员内部类,局部内部类,匿名内部类,静态内部类
2. 成员内部类
    1. 成员内部类可以随意访问外部类的包括private的属性及方法
    2. 成员内部类依附外部类而存在,如果要创建成员内部类的对象,前提是必须存在1个外部类对象.
		```
		public class T1 {
			private String s1 = "s1";
			private void s1(){
				System.out.println("T1.s1:"+s1);
			}
			private String s2 = "s2";
			private void s2(){
				System.out.println("T1.s2:"+s2);
			}
			
			@SuppressWarnings("unused")
			public static void main(String[] args) {
				//要创建1个成员内部类对象,必须先存在外部类对象,通过外部类对象进行创建
				T1 t1 = new T1();
		//		InClass1 inClass1 = t1.new InClass1();
				InClass1 inClass1 = t1.getInClass1Instance();
				inClass1.do1();
				inClass1.do2();
			}
			InClass1 getInClass1Instance(){
				return new InClass1();
			}
			class InClass1{
				public void do1(){
					//成员内部类可以随意访问外部类的属性及方法,包括private
					System.out.println("InClass1:do1;s1:"+s1);
					s1();
				}
				public void do2(){
					System.out.println("InClass1:do1;s2:"+s2);
					s2();
				}
			}
		}
		```
    3. 局部内部类
		1. 局部内部类是定义在1个方法或者作用域内的类.局部内部类的访问权限仅限于该方法或者作用域内.
		2. 局部内部类就像方法里的1个局部变量一样,不能用public、protected、private以及static修饰.
		3. 代码实例
		```
		public class T1 {
			public static void main(String[] args) {
				T1 t1 = new T1();
				t1.getWoman().p();
			}
			class People{
				public void p(){
					System.out.println("People:p");
				}
			}
			public People getWoman(){
				class Woman extends People{}
				return new Woman();
			}
		}
		```
	4. 匿名内部类
		1. 匿名内部类是平时用的最多的.设置事件监听.
		2. 使用匿名内部类能够在实现父类或者接口中的方法情况下同时产生1个相应的对象
		3. 代码实例
		```
		public class T1 {
			private String s1 = "s1";
			private void s1(){
				System.out.println("T1.s1:"+s1);
			}
			private String s2 = "s2";
			private void s2(){
				System.out.println("T1.s2:"+s2);
			}
			
			@SuppressWarnings("unused")
			public static void main(String[] args) {
				T1 t1 = new T1();
				t1.setListener(new Listener() {
					@Override
					public void do1() {
						System.out.println("Listener:do1");
					}
				});
			}
			
			interface Listener{
				void do1();
			}
			private void setListener(Listener l){
			}
		}
		```
	5. 静态内部类
		1. 静态内部类是不需要依赖于外部类的
		2. 代码实例
		```
		public class T1 {
			public static void main(String[] args) {
			}
			static int a = 100;
			int b = 200;
			static class sClass{
				void do1(){
					//静态内部类可以调用外部类的静态方法及静态变量
					//不能调用外部类的非static方法及变量
					main(null);
					a++;
					b++;//会报错.因为静态内部类不依赖外部类的实例化,非static变量是和外部类实例化后才会加载.
				}
			}
		}
		```
	6. 深入理解内部类
        1. 成员内部类
			在编译期,成员内部类会被单独编译为1个字节码文件.<br>
			如上面的T1和InClass1,会被编译为 T1.class 和 T1&InClass1.class 两个class文件<br/>
			编译器会默认为成员内部类添加了一个指向外部类对象的引用
			当成员内部类和外部类拥有相同名称的成员变量，在内部类中调用访问，默认情况下访问的是成员内部类的成员变量;<br>
			要访问外部类的成员变量,要使用 外部类.this.成员变量 的形式
            ```
            public class JavaTest1 {
            	public static void main(String[] args) {
            		JavaTest1 t = new JavaTest1();
            		InClass c = t.new InClass();
            		c.p();
            	}
            	private int a = 300;
            	class InClass{
            		private int a = 100;
            		public void p(){
            			int a = 200;
            			System.out.println("a:"+a);
            			System.out.println("this.a:"+this.a);
            			System.out.println("JavaTest1.this.a:"+JavaTest1.this.a);
            		}
            	}
            }
            
            a:200
            this.a:100
            JavaTest1.this.a:300
            ```
		2. 为何局部内部类和匿名内部类只能访问局部final变量?
            ```
            class People{
            	public void p(){
            		System.out.println("People:p");
            	}
            }
            public People getWoman(){
            	final int a = 10;
            	class Woman extends People{
            		@Override
            		public void p() {
            			super.p();
            			System.out.println("Woman a:"+a);
            		}
            		void pp(){
            			System.out.println("pp");
            		}
            	}
            	return new Woman();
            }
            ```
            1. getWoman调用结束之后,a的生命周期就结束了,但是return new Woman()这个Woman实例的生命周期很可能没结束
            2. 为了防止在a的生命周期结束后继续使用a,Java将a进行了拷贝放在了匿名内部类/局部内部类内部
            3. 如果在a生命周期结束后,Woman实例继续对a进行变更,就会造成数据不一致.为了防止数据不一致,则限制局部变量只能为final,不可变更.
        3. 为何成员内部类不能有静态方法和静态变量?
            1. 成员内部类,本质上相当于外部类的一个非静态变量,它的加载依赖于外部类的实例化;
            2. 而java虚拟机要求静态成员的加载不能依赖类的实例化;
			两者是矛盾的,因而不能包含静态成员.

#### 2.string-stringbuffer-stringbuilder区别
1. String:字符串常量
2. StringBuffer:线程安全的字符串变量
3. StringBuilder:非线程安全的字符串变量
	1. String是不可变对象.每次对String进行修改都相当于生成了一个新的String对象,然后将原始字符串的指针指向新String对象.<br>
	所以对于需要经常改变的字符串,每次改变都会生成新的对象,频繁创建新对象会影响性能.当内存中无引用对象多了就会触发JVM的GC.
	2. StringBuffer是线程安全的可变字符串序列,每次改变都是对StringBuffer实例本身进行变更,不会创建新的对象,性能远远好于String
	3. StringBuilder是非线程安全的可变字符串序列,在不考虑线程安全情况下推进使用StringBuilder,性能比StringBuffer更好.
	4. 代码实例:由此可见,StringBuilder和StringBuffer的性能远好于String. StringBuilder>StringBuffer>String
	```
	public class JavaTest1 {
		public static void main(String[] args) {
			String s = "";
			StringBuffer buffer = new StringBuffer();
			StringBuilder builder = new StringBuilder();
			long start0 = System.currentTimeMillis();
			//String 10万条
			for(int i = 0; i< 100000; i++){
				s+="1";
			}
			long end0 = System.currentTimeMillis();
			long start1 = System.currentTimeMillis();
			//StringBuffer 和 StringBuilder 1000万条
			for(int i = 0; i< 10000000; i++){
				buffer.append("1");
			}
			long end1 = System.currentTimeMillis();
			long start2 = System.currentTimeMillis();
			for(int i = 0; i< 10000000; i++){
				builder.append("1");
			}
			long end2 = System.currentTimeMillis();
			System.out.println("耗时统计:String="+(end0-start0)+"ms;StringBuffer="+(end1-start1)+"ms;StringBuilder="+(end2-start2)+"ms");
		}
	
	耗时统计:String=3804ms;StringBuffer=281ms;StringBuilder=78ms
	```

#### 3.什么导致线程阻塞
1. java提供了以下方法实现线程阻塞:sleep,suspend+resume,yield,wait+notify+notifyAll
2. sleep:使线程在指定毫秒值内进入阻塞状态,不能得到CPU时间.指定时间已过,重新进入可执行状态
3. suspend+resume: suspend让线程进入阻塞状态,且不会自动恢复,必须其对应的resume被调用,线程才能重新进入可执行状态
4. yield:yield使当前线程放弃当前分得的CPU时间,使得调度程序认为当前线程已经执行了足够时间从而转到另1个线程.<br>
		yield执行后当前线程依然处于可执行状态,不会阻塞,随时可以再次获得CPU时间
5. wait+notify
		wait使线程进入阻塞状态,并释放已经获得的锁;notify使线程解除阻塞状态.
6. wait+notify+notifyAll和前面几个方法的区别
    1. wait,notify,notifyAll是隶属于Object的,而前面方法则隶属于Thread.
    2. 前面的方法可以在任意位置调用,而wait,notify,notifyAll则必须在synchronized方法或方法块中调用,原因:
        1. wait不仅会阻塞当前线程,还会释放已经获得的锁.只有在synchronized中当前线程才能获得锁,才有锁可以释放;
        2. 如果在非synchronized方法或代码块中调用wait,notify,notifyAll,就会报异常:java.lang.IllegalMonitorStateException
            ```
            public class T2 {
            	public static void main(String[] args) {
            		Object o = new Object();
            		synchronized (o) {
            			try {
            			        //wait,notify,notifyAll必须在同步代码块
            			        //或同步方法中调用
            //				o.wait();
            				o.wait(1000);
            				o.notify();
            			} catch (InterruptedException e) {
            				// TODO Auto-generated catch block
            				e.printStackTrace();
            			}
            		}
            		//在同步块以外调用触发
            		//java.lang.IllegalMonitorStateException
            		o.notifyAll();
            	}
            }
            ```
7. notify及notifyAll
    1. Object o.notify调用后,比如有多个线程调用过 o.wait,则从这几个被阻塞的线程中随机选1个,解除其阻塞状态.
    2. Object o.notifyAll调用后,比如有多个线程调用过 o.wait,则将这几个被阻塞的线程,全部解除其阻塞状态.
    3. 解除阻塞状态,线程也不一定是可运行状态,只有获得锁,才是可运行状态.

#### 4.Java中线程的状态转换
![线程状态图](https://user-gold-cdn.xitu.io/2018/8/7/165126c29d9b29af?w=968&h=680&f=jpeg&s=91092)
线程包含以下状态: 新建,可运行,运行,阻塞,死亡
1. 新建:新创建了一个线程对象
2. 可运行:Thread被创建后,其他线程调用了其start方法,则Thread进入可运行状态.<br>,等待被操作系统选中,获取CPU的使用权
3. 运行:可运行状态的Thread被操作系统选中,获取了CPU时间片,执行代码
4. 阻塞:运行状态的Thread放弃了CPU的使用权,让出了CPU时间片,暂时停止运行<br>z直到该线程再次进入可运行状态,才有机会重新获取CPU使用权进入运行状态.<br>
阻塞情况分3种:
    1. 运行状态的Thread执行Object o.wait,JVM会把线程放入等待队列中
    2. 运行状态的Thread执行synchronized(Object o)时,若该对象的同步锁已被其他线程占用,JVM会将该线程放入锁池中
    3. 运行状态的Thread执行Thread.sleep,Thread.join,或发出了IO请求,则JVM会将其设置为阻塞状态.当sleep超时,join等待的线程终止或超时,或IO执行完毕,该线程会重新进入 可运行状态
5. 死亡:线程的run方法结束,或因异常退出了run方法,则该线程死亡,生命周期结束.

#### 5.synchronized和Lock
- **synchronized**
    - synchronized是Java中的关键字,利用锁机制来实现同步
    - synchronized使用位置
        - 修饰代码块
            - 1:synchronized(this|Object){}     修饰对象获取的是对象锁
            - 2:synchronized(类.class){}        修饰类.class获取的是类锁
        - 修饰方法
            - 3:synchronized static method(){}      修饰静态方法获取的是类锁
            - 4:synchronized method(){}             修饰非静态方法获取的是对象锁
    - 每个对象有1个对象锁,1个类下所有对象共用1个类锁
    - 线程A获取了类锁,在A释放类锁前,其他线程无法获取到类锁
    - 同1个类的多个对象,其多个对象锁彼此独立
        - 线程A获取了S1的对象锁,在A释放对象锁之前,其他线程无妨获取到S1的对象锁
        - 线程A获取了S1的对象锁,不影响其他线程获取S2,S3---的对象锁
    - 对象锁和类锁彼此独立
        - 线程A获取了S1的对象锁,可以同时获取S1所属类的类锁
        - 线程A获取了S1的对象锁,线程B可以获取S1所属类的类锁
- **Lock**
    - 使用Lock可以更灵活/更繁琐的解决线程安全/数据同步问题
    - 我们可以使用ReentrantLock和ReentrantReadWriteLock
    - Lock需要 手动加锁,共享数据访问放到try块内,并在finally中手动释放锁
    - ReentrantLock实例
        ```
        public class T2 {
        	public static void main(String[] args) {
        		T2 t = new T2();
        		t.t();
        	}
        	private void t(){
        		new Thread(new Runnable() {
        			@Override
        			public void run() {
        				execute(true);
        			}
        		}).start();
        		new Thread(new Runnable() {
        			@Override
        			public void run() {
        				execute(false);
        			}
        		}).start();
        	}
        	
        	private int a = 0;
        	private ReentrantLock lock = new ReentrantLock();
        	private void execute(boolean increase){
        		//手动加锁
        		lock.lock();
        		try {
        		    //共享数据访问包在try块中
        			for(int i = 0; i < 1000; i++){
        				if(increase){
        					a++;
        				}else{
        					a--;
        				}
        				System.out.println("a:"+a);
        			}
        		} catch (Exception e) {
        		} finally{
        			//finally中手动释放锁
        			lock.unlock();
        		}
        	}
        }
        
        a:1
        a:2
        a:3
        a:4
        a:5
        a:6
        ----
        a:1000
        a:999
        a:998
        a:997
        a:996
        a:995
        ----
        a:2
        a:1
        a:0
        ```
    - ReadWriteLock实例:读取共享数据的方法中使用readLock,设置共享数据的方法中使用writeLock
        ```
        public class T2 {
        	public static void main(String[] args) {
        		T2 t = new T2();
        		t.t();
        	}
        	
        	private String s = "s";
        	private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
        	private Lock read = readWriteLock.readLock();
        	private Lock write = readWriteLock.writeLock();
        	public String getS() {
        		read.lock();
        		try {
        			Thread.sleep(20);
        			return s;
        		} catch (Exception e) {
        			return null;
        		} finally{
        			read.unlock();
        		}
        	}
        	public void setS(String s) {
        		write.lock();
        		try {
        			Thread.sleep(50);
        			this.s = s;
        		} catch (Exception e) {
        		} finally{
        			write.unlock();
        		}
        	}
        	private void t(){
        		new Thread(new Runnable() {
        			@Override
        			public void run() {
        				exe(false);
        			}
        		}).start();
        		new Thread(new Runnable() {
        			@Override
        			public void run() {
        				exe(false);
        			}
        		}).start();
        		new Thread(new Runnable() {
        			@Override
        			public void run() {
        				exe(true);
        			}
        		}).start();
        		new Thread(new Runnable() {
        			@Override
        			public void run() {
        				exe(false);
        			}
        		}).start();
        		new Thread(new Runnable() {
        			@Override
        			public void run() {
        				exe(false);
        			}
        		}).start();
        		new Thread(new Runnable() {
        			@Override
        			public void run() {
        				exe(false);
        			}
        		}).start();
        	}
        	private void exe(boolean set){
        		for(int i = 0; i< 100; i++){
        			if(set){
        				setS("滚你妹:"+i);
        				System.out.println("ThreadId:"+Thread.currentThread().getId()+";setS:"+s);
        			}else{
        				String s = getS();
        				System.out.println("ThreadId:"+Thread.currentThread().getId()+";getS:"+s);
        			}
        		}
        	}
        }
        ThreadId:9;getS:s
        ThreadId:10;getS:s
        ThreadId:11;setS:滚你妹:0
        ThreadId:13;getS:滚你妹:0
        ThreadId:9;getS:滚你妹:0
        ThreadId:12;getS:滚你妹:0
        ThreadId:14;getS:滚你妹:0
        ThreadId:10;getS:滚你妹:0
        ThreadId:11;setS:滚你妹:1
        ThreadId:14;getS:滚你妹:1
        ThreadId:12;getS:滚你妹:1
        ThreadId:9;getS:滚你妹:1
        ThreadId:13;getS:滚你妹:1
        ThreadId:10;getS:滚你妹:1
        ThreadId:11;setS:滚你妹:2
        ThreadId:14;getS:滚你妹:2
        ThreadId:9;getS:滚你妹:2
        ThreadId:13;getS:滚你妹:2
        ThreadId:12;getS:滚你妹:2
        ThreadId:10;getS:滚你妹:2
        ThreadId:11;setS:滚你妹:3
        ThreadId:12;getS:滚你妹:3
        ThreadId:9;getS:滚你妹:3
        ThreadId:13;getS:滚你妹:3
        ThreadId:10;getS:滚你妹:3
        ThreadId:14;getS:滚你妹:3
        ThreadId:11;setS:滚你妹:4
        ThreadId:14;getS:滚你妹:4
        ThreadId:9;getS:滚你妹:4
        ThreadId:12;getS:滚你妹:4
        ThreadId:13;getS:滚你妹:4
        ThreadId:10;getS:滚你妹:4
        ```

#### 6.HashMap,SparseArray,ArrayMap区别及性能分析
HashMap结构:
![](https://user-gold-cdn.xitu.io/2018/8/7/16513806a20e95ff?w=474&h=373&f=png&s=24855)
SparseArray结构:
![](https://user-gold-cdn.xitu.io/2018/8/7/16513813d5131851?w=311&h=245&f=png&s=14121)
ArrayMap结构:
![](https://user-gold-cdn.xitu.io/2018/8/7/1651380bc6dc5137?w=366&h=394&f=png&s=23189)
1. 首先3者的结构不同.HashMap是使用数组+单链表的形式存储数据;SparseArray和ArrayMap都是采用2个数组形式存储数据;
    - 因为hash的值不是连续的，所以hashmap实际需要占用的大小会比它实际能装的item的容量要大;
    - ArrayMap使用int[] mHashes来连续存储Key的hash值,查询时候采用二分查找获取指定Key的index;
    - SparseArray相对于ArrayMap仅仅支持key类型为int(Integer都不行)的情况,内部结构和ArrayMap类似;
    - 数据结构的不同导致SparseArray和ArrayMap更加节省内存.
2. 有人做过3者的性能实验
    - key为int情况下,数据量1000以内,SparseArray相比较HashMap内存节省30%;<br>
    ArrayMap只能节省10%
    - 查询时间性能上,ArrayMap是最差的;对于HashMap和SparseArray,如果HashMap使用map.get(Integer)则性能高于SparseArray,如果使用map.get(int),因为涉及自动装箱过程,性能低于SparseArray.
    - 根据上面实验,ArrayMap就是垃圾,用不着.SparseArray几乎也用不着.很少会用到key类型为int的情况.如果遇到,且存储数量低于1000,可以使用.

#### 7.Java容器类
1. Java容器工具包框架图
![Java容器工具包框架图](https://user-gold-cdn.xitu.io/2018/8/8/1651774531bfdb6d?w=1576&h=586&f=jpeg&s=134080)
2. Java容器主要包括两部分:Collection和Map
    1. Collection有很多子接口,用到最多的是List,Set,Queue
    2. Map用到比较多的是HashMap,HashTable,TreeMap
3. List
    - List是1个有序队列,其中的每个元素有对应的索引值,索引值从0开始
    - 可以通过索引值对元素进行精确的获取,添加,删除
    - 可以允许插入重复的元素
    - List用到比较多的是ArrayList / LinkedList / Vector分别是什么,3者区别:
        - Vector是线程安全的动态数组.内部使用对象数组来保存数据,可以根据需要自动的增加容量,当数组已满,会创建新的数组,并拷贝原有数组数据.
        - ArrayList是非线程安全的动态数组实现.在单线程环境下因为没有同步开销,相对Vector性能会好很多.ArrayList也可以根据需要调整容量.但Vector和ArrayList的容量调整逻辑有区别.后面会详述.
        - LinkedList是Java提供的双向链表,它不像上面那样调整容量,也不是线程安全的.
    - 为什么Vector线程安全,ArrayList和LinkedList非线程安全?看源码就知道<br>
        添加或删除元素的方法,Vector是同步操作
        ```java
        Vector
            public synchronized boolean add(E e) {
            public synchronized void removeElementAt(int index) {
        ArrayList
            public boolean add(E e) {
            public E remove(int index) {
        LinkedList
            public boolean add(E e) {
            public E remove(int index) {
        ```
    - 多线程环境下,为了保证线程安全应使用Vector,单线程环境下,Vector不建议使用,同步会产生额外的性能开销
    - 多线程环境下一定要使用ArrayList或LinkedList:
        ```
        List list = Collections.synchronizedList(new LinkedList(…));
        List list = Collections.synchronizedList(new ArrayList(…));
        ```
    - Vector和ArrayList是动态数组,内部元素是通过数组按顺序存储,所以随机访问很快;但是要在中间添加或者删除1个元素,就需要移动后续所有元素,性能较差;
    - LinkedList作为双向链表,进行节点插入,删除,只需要改变前后两个元素的next和pre即可,效率很高.但是相比较Vector和ArrayList,随机访问性能要差.
    - Vector和ArrayList的容量调整逻辑有何区别?要看代码
        ```java
        Vector.java
        public class Vector<E> extends AbstractList<E> 
            implements List<E>, RandomAccess, Cloneable, java.io.Serializable{
            
            //实际承载数据的动态数组
            protected Object[] elementData;
            //当前实际包含的元素个数
            protected int elementCount;
            //Vector扩容时候自动增加的容量
            protected int capacityIncrement;
            
            
            public Vector(int initialCapacity, int capacityIncrement) {
                super();
                if (initialCapacity < 0)
                    throw new IllegalArgumentException("Illegal Capacity: "+
                                                       initialCapacity);
                this.elementData = new Object[initialCapacity];
                this.capacityIncrement = capacityIncrement;
            }
            //2:这种情况下capacityIncrement依然是0
            public Vector(int initialCapacity) {
                this(initialCapacity, 0);
            }
            //1:默认情况下,elementData初始长度是10,capacityIncrement=0
            public Vector() {
                this(10);
            }
            //扩容操作
            private void grow(int minCapacity) {
                int oldCapacity = elementData.length;
                //当capacityIncrement>0,则每次扩容,容量增加个数为capacityIncrement
                //当当capacityIncrement=0,则每次扩容,容量*2
                int newCapacity = oldCapacity + ((capacityIncrement > 0) ?
                                                 capacityIncrement : oldCapacity);
                ***
                elementData = Arrays.copyOf(elementData, newCapacity);
            }
        }
        ```
        - 代码可见,对于Vector而言,每次扩容,容量变化取决于创建Vector时调用了哪个构造函数.<br>
        对于new Vector(),new Vector(initialCapacity),每次扩容容量*2;<br>
        对于new Vector(int initialCapacity, int capacityIncrement),每次扩容容量增加值就是capacityIncrement
        ```java
        ArrayList.java
        public class ArrayList<E> extends AbstractList<E>
            implements List<E>, RandomAccess, Cloneable, java.io.Serializable
        {
            private void grow(int minCapacity) {
                int oldCapacity = elementData.length;
                //每次扩容,容量增加值为现有容量的1/2:oldCapacity >> 1
                int newCapacity = oldCapacity + (oldCapacity >> 1);
                ***
                elementData = Arrays.copyOf(elementData, newCapacity);
            }
        }
        ```
        - 代码可见,对于ArrayList,每次扩容,容量增加值为:现有容量/2
4. Set
    - Set中不允许存在重复元素,即不存在两个元素equals返回true.这是和List最明显的区别
    - Set中用到最多的是HashSet和TreeSet
        - HashSet内部实际上是由1个HashMap支持,提供元素的添加移除.见源码
            ```java
            HashSet.java
            
            public class HashSet<E>
                extends AbstractSet<E>
                implements Set<E>, Cloneable, java.io.Serializable
            {
                //这就是为HashSet提供底层支撑的HashMap
                private transient HashMap<E,Object> map;
                //存储和移除时重复使用的实例
                private static final Object PRESENT = new Object();
                //HashSet执行add操作,是将元素作为key,PRESENT作为value存入了HashMap
                public boolean add(E e) {
                    return map.put(e, PRESENT)==null;
                }
                //HashSet执行remove操作,本质是移除HashMap中指定元素作为key存储的PRESENT
                public boolean remove(Object o) {
                    return map.remove(o)==PRESENT;
                }
            }
            ```
            集合元素可以是null,但只能放入一个null;<br>
            底层使用HashMap将元素存储为key,所以内部元素排序是按照哈希码排序的.随着不同元素添加,排序会不断变化;
            <br>
            HashSet也不是线程安全的,多线程下,类似ArrayList和LinkedList,也要:<br>
            
            ```java
            Set s = Collections.synchronizedSet(new HashSet);
            ```
            <br>
            HashSet堪称查询速度最快的集合，因为其内部是以HashCode来实现
        - TreeSet底层基于TreeMap.使用元素的自然顺序对元素进行排序，或者根据创建 set 时提供的 Comparator 进行排序.
            - 1个正确的TreeSet,其内部元素类应该正确的实现compare方法,或者在构造函数中提供正确的Comparator.以保证内部元素排序正确;
            - TreeSet也不是线程安全的,多线程下使用:
                ```java
                SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...));
                ```
            - TreeSet底层由TreeMap支持
                ```java
                TreeSet.java
                
                public class TreeSet<E> extends AbstractSet<E>
                    implements NavigableSet<E>, Cloneable, java.io.Serializable
                {
                    //实际存储数据的TreeMap
                    private transient NavigableMap<E,Object> m;
                    private static final Object PRESENT = new Object();
                    TreeSet(NavigableMap<E,Object> m) {
                        this.m = m;
                    }
                    public TreeSet() {
                        //构造TreeMap
                        this(new TreeMap<E,Object>());
                    }
                    public TreeSet(Comparator<? super E> comparator) {
                        this(new TreeMap<>(comparator));
                    }
                    public boolean add(E e) {
                        //TreeMap实际存储数据
                        return m.put(e, PRESENT)==null;
                    }
                }
                
                TreeMap.java
                public class TreeMap<K,V>
                    extends AbstractMap<K,V>
                    implements NavigableMap<K,V>, Cloneable, java.io.Serializable
                {
                    public V put(K key, V value) {
                        ****
                        cmp = cpr.compare(key, t.key);
                        if (cmp < 0)
                            t = t.left;
                        else if (cmp > 0)
                            t = t.right;
                        else
                            return t.setValue(value);
                        ****
                        //根据compare的值来进行排序
                        Entry<K,V> e = new Entry<>(key, value, parent);
                        if (cmp < 0)
                            parent.left = e;
                        else
                            parent.right = e;
                    }
                }
                ```
5. Queue/Deque,是Java提供的标准队列结构实现.支持先入先出 或 后入先出 等特定行为.具体看数据结构部分
6. Map
    - Map是1系列的键值对,提供了key到value的映射;key和value一一对应.
    - Map中key不能重复,value可以重复
    - Map的实现类常用的有 HashMap,WeakHashMap,HashTable,TreeMap
        - HashTable是Java提供的一个哈希表实现,不支持null键和值.本身支持同步,线程安全.但同步需要额外的性能开销,单线程下不推荐使用
        - HashMap也是Java提供的哈希表实现.相对HashTable,支持null键和null值,且不支持同步,非线程安全.单线程下绝大部分情况使用HashMap
            - 多线程下使用HashMap:
            ```
            Map m = Collections.synchronizedMap(new HashMap(...));
            ```
        - TreeMap是一种基于红黑树的一种提供顺序访问的Map.key的排序取决于key的自然顺序(key所属类的compare方法),或构建TreeMap时候提供的Comparator实例.TreeMap也不支持同步.
            - 多线程下使用TreeMap:
            ```
            SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));
            ```
7. LinkedHashMap
    - LinkedHashMap是1个可预知迭代顺序的Map.通过维护一个运行于所有条目的双向链表,LinkedHashMap保证了元素迭代的顺序.该迭代顺序可以是插入顺序或者是访问顺序。
    - [linkedHashMap](https://www.cnblogs.com/xiaoxi/p/6170590.html)
    - LindedHashMap可以认为是使用HashMap存储数据,又使用LinkedList维护键值对的迭代顺序.见源码:
        ```java
        LinkedHashMap.java
        
        public class LinkedHashMap<K,V>
            extends HashMap<K,V>
            implements Map<K,V>
        {
            //双向链表的头结点
            private transient Entry<K,V> header;
            //控制迭代器顺序:
            //true 按照访问顺序 依次迭代
            //false 按照插入顺序(put顺序)
            private final boolean accessOrder;
            
            //继承于HashMap,在未执行put前初始化HashMap实例.
            @Override
            void init() {
                //此处初始化header,header的before和after都为自身
                header = new Entry<>(-1, null, null, null);
                header.before = header.after = header;
            }
            
            //LinkedHashMap并没有重写put.HashMap的put会依次调用
            //addEntry和createEntry,
            //查看LinkedHashMap的这两个方法即可
            void addEntry(int hash, K key, V value, int bucketIndex) {
                //继承HashMap逻辑
                super.addEntry(hash, key, value, bucketIndex);
                //如果header.after作为参数,removeEldestEntry返回true,
                //即执行removeEntryForKey
                Entry<K,V> eldest = header.after;
                if (removeEldestEntry(eldest)) {
                    removeEntryForKey(eldest.key);
                }
            }
            void createEntry(int hash, K key, V value, int bucketIndex) {
                //除了e.addBefore(header),其余逻辑和HashMap一致
                //此处的e是LinkedHashMap.Entry
                //1:分析e.addBefore(header)
                HashMap.Entry<K,V> old = table[bucketIndex];
                Entry<K,V> e = new Entry<>(hash, key, value, old);
                table[bucketIndex] = e;
                e.addBefore(header);
                size++;
            }
            
            //1:分析e.addBefore(header)
            private static class Entry<K,V> extends HashMap.Entry<K,V> {
                // 用于在双向链表中标记前后关系的Entry
                Entry<K,V> before, after;
                ****
                private void remove() {
                    before.after = after;
                    after.before = before;
                }
                //关键位置是addBefore
                private void addBefore(Entry<K,V> existingEntry) {
                    after  = existingEntry;
                    before = existingEntry.before;
                    before.after = this;
                    after.before = this;
                }
            }
        }
        ```
        - 对于header而言,初始化时候:<br>
        header = new Entry<>(-1, null, null, null),<br>
        其hash=-1,K,V,next都是null,before和after都是header自身.
        - 每次createEntry都会构建新的Entry,然后执行e.addBefore(header)
        - LinkedHashMap存储键值对的逻辑和HashMap无异,这里只看其双向链表维护逻辑.对照代码画一下,看前3次:
        ![LinkedHashMap双向链表维护逻辑](https://user-gold-cdn.xitu.io/2018/8/9/1651dddf938f115a?w=539&h=748&f=jpeg&s=134510)
        - 由图可见:<br>
        第1次执行put,header和Entry e1互为before,互为after;<br>
        第2次,Entry e2被插入双向链表的尾部.e1是e2的before,e2是e1的after;同时header的before被替换成e2,e2的after是header;<br>
        第3次,和第2次类似.header的before替换为e3,e3的after是header;<br><br>
        **规律:<br>每次新创建的Entry e 被添加到双向链表尾部,e作为header的before,header作为e的after;<br>
        即单纯考虑put,双向链表会按照put顺序依次向链表尾部插入Entry,维护迭代顺序.**
    - 我们可以重写LinkedHashMap的removeEldestEntry方法,自动将**最不常被访问的对象**释放掉.
        - addEntry源码:
            ```java
            void addEntry(int hash, K key, V value, int bucketIndex) {
                super.addEntry(hash, key, value, bucketIndex);
        
                // Remove eldest entry if instructed
                Entry<K,V> eldest = header.after;
                if (removeEldestEntry(eldest)) {
                    //根据key删除'最不常被访问的对象'
                    removeEntryForKey(eldest.key);
                }
            }
            ```
        - header.after会作为参数传入removeEldestEntry,我们可以自定义逻辑,删除**最不常被访问的对象.问题来了,最不常被访问的对象(header.after)到底是谁?**
            - 单纯考虑put情况,header.after必然是第一次put时的Entry
            - 再看get,获取到Entry,然后调用recordAccess
                ```java
                public V get(Object key) {
                    Entry<K,V> e = (Entry<K,V>)getEntry(key);
                    if (e == null)
                        return null;
                    e.recordAccess(this);
                    return e.value;
                }
                //accessOrder默认是false
                //只有在创建LinkedHashMap时候传入true,accessOrder才可能是true
                public LinkedHashMap(int initialCapacity,
                 float loadFactor,
                 boolean accessOrder) {
                    super(initialCapacity, loadFactor);
                    this.accessOrder = accessOrder;
                }
                
                Entry:
                void recordAccess(HashMap<K,V> m) {
                    LinkedHashMap<K,V> lm = (LinkedHashMap<K,V>)m;
                    //accessOrder为true,才继续执行remove,addBefore
                    if (lm.accessOrder) {
                        lm.modCount++;
                        remove();
                        //addBefore之前分析过,将当前Entry添加到双向链表的尾部;
                        //并将header的before指向当前Entry,当前Entry的after指向header
                        addBefore(lm.header);
                    }
                }
                private void remove() {
                    //将before和after对当前Entry的引用移除,相当于在双向链表中删除了当前Entry
                    before.after = after;
                    after.before = before;
                }
                ```
                - 可见如果没有调用指定构造方法,并传入true,在执行get时关联的Entry就不会执行recordAccess
                - 如果accessOrder已经是true,执行get会将关联的Entry从双向链表中间移除,并插入到双向链表的尾部.如果之前关联Entry就是就是header.after,执行recordAccess结束后,header.after会变成关联Entry之前的after.
            - **总结:<br>
            若LinkedHashMap创建时候没有调用public LinkedHashMap(int initialCapacity,float loadFactor,boolean accessOrder)或传入的accessOrder为false,则header.after总是第1次put关联的Entry;<br><br>
            若传入的accessOrder为true:**
                - 只执行过put,未执行过get,header.after也是第1次put关联的Entry
                - 执行过get,如果get关联的Entry e,执行get前就是header.after,get执行后header.after会变更为 e 在get执行前的after.
    - 重写removeEldestEntry,删除'最不常被访问的对象'示例
        ```java
        public class LinkedHashMapT2 {
        	public static void main(String[] args) {
        		LinkedHashMap<String, String> accessOrderedMap = new LinkedHashMap<String, String>(16, 0.75F, true) {
        			@Override
        			protected boolean removeEldestEntry(Map.Entry<String, String> eldest) {
        				// 实现自定义删除策略，否则行为就和普遍 Map 没有区别
        				return size() > 4;
        			}
        		};
        		accessOrderedMap.put("Project1", "Valhalla");
        		accessOrderedMap.put("Project2", "Panama");
        		accessOrderedMap.put("Project3", "Loom");
        		Set<Map.Entry<String, String>> set1 = accessOrderedMap.entrySet();
        		Iterator<Map.Entry<String, String>> iterator1 = set1.iterator();
        		while(iterator1.hasNext()){
        			Map.Entry<String, String> curr = iterator1.next();
        			System.out.println("key:"+curr.getKey()+";Value:"+curr.getValue());
        		}
        		System.out.println("====================================");
        		// 模拟访问
        		accessOrderedMap.get("Project2");
        		accessOrderedMap.get("Project2");
        		accessOrderedMap.get("Project3");
        		Set<Map.Entry<String, String>> set2 = accessOrderedMap.entrySet();
        		Iterator<Map.Entry<String, String>> iterator2 = set2.iterator();
        		while(iterator2.hasNext()){
        			Map.Entry<String, String> curr = iterator2.next();
        			System.out.println("key:"+curr.getKey()+";Value:"+curr.getValue());
        		}
        		System.out.println("====================================");
        		// 触发删除
        		accessOrderedMap.put("Project4", "Agenda");
        		accessOrderedMap.put("Project5", "Mission Control1");
        		accessOrderedMap.put("Project6", "Mission Control2");
        		Set<Map.Entry<String, String>> set3 = accessOrderedMap.entrySet();
        		Iterator<Map.Entry<String, String>> iterator3 = set3.iterator();
        		while(iterator3.hasNext()){
        			Map.Entry<String, String> curr = iterator3.next();
        			System.out.println("key:"+curr.getKey()+";Value:"+curr.getValue());
        		}
        	}
        }
        
        key:Project1;Value:Valhalla
        key:Project2;Value:Panama
        key:Project3;Value:Loom
        ====================================
        key:Project1;Value:Valhalla
        key:Project2;Value:Panama
        key:Project3;Value:Loom
        ====================================
        key:Project3;Value:Loom
        key:Project4;Value:Agenda
        key:Project5;Value:Mission Control1
        key:Project6;Value:Mission Control2
        ```
8. HashMap源码解析
9. HashMap问题解答
    1. HashMap多线程put的时候可能导致元素丢失,看源码
        ```java
        HashMap.java
        
        public V put(K key, V value) {
            ****
            addEntry(hash, key, value, i);
            ****
        }
        void addEntry(int hash, K key, V value, int bucketIndex) {
            ****
            createEntry(hash, key, value, bucketIndex);
        }
        void createEntry(int hash, K key, V value, int bucketIndex) {
            //假设多个线程同时执行到1,则e的值都相同
            Entry<K,V> e = table[bucketIndex];//1:
            //然后多个线程执行不同时间执行完2,因为e是相同的,所以只有最后执行2的线程,才是有效的,之前线程执行的2,其结果都会被覆盖
            table[bucketIndex] = new Entry<>(hash, key, value, e);//2:
            size++;
        }
        ```
    2. HashMap在高并发情况下可能引起死循环,CPU占用100%<br>
        先看源码:
        ```java
        public V put(K key, V value) {
            ****
            addEntry(hash, key, value, i);
            return null;
        }
        void addEntry(int hash, K key, V value, int bucketIndex) {
            if ((size >= threshold) && (null != table[bucketIndex])) {
                resize(2 * table.length);
                ****
            }
            ****
        }
        void resize(int newCapacity) {
            ****
            transfer(newTable, initHashSeedAsNeeded(newCapacity));
            ****
        }
        void transfer(Entry[] newTable, boolean rehash) {
            int newCapacity = newTable.length;
            for (Entry<K,V> e : table) {
                while(null != e) {
                    //位置1
                    Entry<K,V> next = e.next;
                    if (rehash) {
                        e.hash = null == e.key ? 0 : hash(e.key);
                    }
                    //假设对于table[0],对应的i为3
                    int i = indexFor(e.hash, newCapacity);
                    e.next = newTable[i];
                    newTable[i] = e;
                    e = next;
                }
            }
        }
        ```
        问题就出在transfer.HashMap执行put操作,可能会触发HashMap的扩容:resize->transfer<br>
        transfer里面会遍历table,将每1个单链表上所有元素移动到新tab的指定位置,并为其设置next.<br><br>
        **假设:<br>有2个线程T1,T2,同时对table[0]进行操作,table[0]对应的单链表是A->B->C;<br>而将要生成的新的table是newTable,0对应的新的索引值是3<br>**
        
        **T1执行到位置1,因为某种原因被挂起,此时对于T1而言:<br>
        e = table[0] = A; next = A.next = B;**<br><br>
        **T2则执行完毕,每一次循环后结果是:**<br>
        **第1次循环:**<br>
        e = table[0] = A;<br>
        next = A.next = B;<br>
        i = 3;//假设<br>
        A.next = newTable[3];<br>
        newTable[3] = e = A;<br>
        e = next = B;<br>
        **第2次循环:**<br>
        next = e.next = C;<br>
        B.next = newTable[3] = A;<br>
        newTable[3] = e = B;<br>
        e = next = C;<br>
        **第3次循环:**<br>
        next = e.next = null;<br>
        C.next = newTable[3] = B;<br>
        newTable[3] = e = C;<br>
        e = next = null; **e=null,循环结束**<br>
        **此时对于newTable,newTable[3]是实际是:C->B->A**<br><br>
        **假如这时T1重新恢复运行,对于T1而言:e = table[0] = A; next = A.next = B;**<br>
        **第1次循环:**<br>
        e = A;<br>
        next = B;<br>
        A.next = newTable[3] = C;<br>
        newTable[3] = e = A;<br>
        e = next = B;<br>
        由于T2执行完毕,B的next已经是A.所以现在newTable[3]实际情形是:<br>
        **newTable[3]:A->C->B B又指向了A,形成了1个环装结构**<br>
        **这样e=next就永远不为null,会无限执行下去.导致CPU 100%.**<br><br>
        **图示:**<br>
        **T1执行到位置1被挂起,T2正常执行完毕+T1恢复执行**
        ![T1执行到位置1被挂起,T2正常执行完毕](https://user-gold-cdn.xitu.io/2018/8/9/1651ce9cc8bd19b5?w=972&h=1459&f=jpeg&s=477196)
        ![T1恢复执行](https://user-gold-cdn.xitu.io/2018/8/9/1651cf0b43536c94?w=1080&h=842&f=jpeg&s=308679)
    3. 为什么HashMap数组初始化大小要设置成2的n次幂?先看源码:
        ```java
        HashMap.java
        
        public V put(K key, V value) {
            ****
            //首先调用indexFor计算Key对应的数组索引
            int i = indexFor(hash, table.length);
            ****
        }
        static int indexFor(int h, int length) {
            //索引是通过:hash和数组长度-1 执行 &运算得到
            return h & (length-1);
        }
        ```
        - key对应的数组索引值,是key得到的hash值和数组长度-1 做一次'与'运算得到.
        - &"与运算"规则:
            1. 要先把运算符两侧的数转化为二进制数,
            2. 如果相对应位都是1，则结果为1，否则为0
            3. 10 & 12:8
                - 10:1010
                - 12:1100
                -    1000 = 8
        - length - 1:
            1. 如果数组大小(length)是2的n次幂,则length-1转换为2进制,每1位都是1
                - 16-1=15:1111
            2. 如果length不是2的n次幂,转换为2进制,有的位上就会是0
                - 15-1=14:1110
        - h & (length-1):X
            1. 2次幂:X的每1位上都有0和1两种可能
            2. 不是2次幂:因为length-1的2进制,有的位上是0,这1位上只会是0,所以X值的组合可能数量低
            3. 也就是说数组长度不是2的N次幂,不同hash运行indexFor出现碰撞可能性更大(因为可选择性更低).
        - 非2次幂的缺点:
            1. 可以存放元素的位置比数组长度小很多,空间浪费很大
            2. 数据分布不均匀,更容易出现hash碰撞,在指定索引形成单链表,查询时候要对单链表遍历,降低效率.
    4. 负载因子(loadFactor)为什么会影响HashMap性能
        - HashMap大致结构
            1. 有序数组按顺序存储数据,对数据的查询性能很高,但是在中间插入和删除数据,则需要依次移动受影响位置后面所有的元素,所以插入删除效率低;
            2. 链表查询数据则需要从链表头依次遍历,查询性能低,插入和删除效率高;
            3. HashMap就是将两者结合产生的结构
        - HashMap可以装载的键值对数量 threshold = capacity * loadFactor
            1. 在容量(capacity)一定情况下,loadFactor越大,threshold越大,HashMap可以存储的键值对越多,发生Hash碰撞的几率越大,形成的单链表就越长,查询效率机会越低;
            2. capacity确定情况下,loadFactor越小,可以存储的键值对越少,发生Hash碰撞的几率越低,单链表越短,查询效率越高;
            3. 但loadFactor过小会导致threshold过小,会经常触发HashMap的扩容,首先很浪费内存空间,其次扩容严重消耗性能;
    5. 创建HashMap时候如何设置initialCapacity和loadFactor
        - 默认情况下,initialCapacity是16,loadFactor是0.75
        - 如果能估计HashMap中存储的键值对数量S,可以计算出initialCapacity
            - ori = S / loadFactor,<br>
            initialCapacity>=s且是2的n次幂
            - 这样设置可以防止扩容影响性能,也不会占用过大空间
        - loadFactor不要轻易更改,系统默认值比较符合通用场景需求
            - 如果要调整loadFactor,不要>0.75,会显著增加hash碰撞,影响查询性能
            - 也不能设置过小,过小会频繁触发扩容影响性能
    6. HashMap的树化:涉及putVal和treeifyBin两个方法
        - treeifyBin源码分析暂略见极客时间
        - HashMap为什么要树化: HashMap树化本质上是1个安全问题.<br>
        HashMap执行put,如果出现key哈希冲突,会将多个Entry放到同1个哈希桶,形成1个单链表;<br>
        链表的查询是线性的,链表过长会严重影响查询性能;<br>
        现实中构建hash冲突的数据并不非常复杂,恶意代码可以利用这些数据大量与服务端交互,从而严重占用服务端CPU,这就构成了哈希碰撞拒绝服务攻击.
10. ConcurrentHashMap: 极客时间和保存的网页一起看

#### 8.重写Object的hashCode和equals,有什么要求(回到家结合保存的网页一起看)
在改写equals方法的时候，需要满足以下三点： 
- 自反性：就是说a.equals(a)必须为true。 
- 对称性：就是说a.equals(b)=true的话，b.equals(a)也必须为true。 
- 传递性：就是说a.equals(b)=true，并且b.equals(c)=true的话，a.equals(c)也必须为true

#### 9.抽象类和接口的区别
1. 接口
    1. 首先看不能怎么写:会直接报错
        ```java
        public interface IT1 {
        	//Interfaces cannot have constructors
        	public IT1(){}
        	//Illegal modifier for the interface field IT1.a; 
        	//only public, static & final are permitted
        	private static int a = 0;
        	//Illegal modifier for the interface method d; 
        	only public & abstract are permitted
        	private void d();
        	//Abstract methods do not specify a body
        	public void b(){}
        	//Illegal modifier for the interface method main; 
        	//only public & abstract are permitted
        	public static void main(String[] args) {
        		
        	}
        }
        ```
        接口不能包含构造函数;<br>
        接口中field必须是public static final;<br>
        接口中只能包含public abstract方法;不允许其他修饰符修饰;<br>
        接口中不能包含main方法;
    2. 接口是对行为的抽象,是抽象方法的集合,不能实例化
    3. java不支持多继承,但可以实现多个接口,因为接口是抽象方法的集合.
2. 抽象类
    1. 抽象类是作为一系列子类的父类,是对一种事物的抽象.
    2. 抽象类是为了被继承而存在,子类可以共用抽象类的具体方法及成员变量,并对抽象方法做不同的实现;
    3. 除了不能实例化(实例化会报错:Cannot instantiate the type AbsClassT1),抽象类和正常Java类无差别
3. 抽象类和接口的区别
    1. 抽象类是一种对事物的抽象,即对类抽象,描述了"是什么";<br>
        接口是对行为的抽象,可以在不同种类的事物中进行实现,描述了"能干什么"
    2. 1个类可以实现多个接口实现灵活的行为扩展,但不能继承多个抽象类从属多个类别
    3. 抽象类可以扩展具体方法,子类代码可直接调用,原始代码无需变动;接口中方法变动,所有实现类都必须实现新添加的方法;
4. 接口和抽象类的1个例子:比如有奶牛,老虎,蝴蝶,怎样使用抽象类和接口进行描述
    ```java
    1:三者都属于动物,因而可以定义Animal抽象类作为父类,动物都有eat公有属性,因而可以将eat作为抽象方法;
    
    2:奶牛可以产奶,老虎会捕猎,蝴蝶会飞,这几个能力互相没有关联,
    不同的动物可能具有其中1项或多项,因而可以定义为3个单独接口:Milk,Hunt,Fly
    
    具体实现:
    public class AbsIT1 {
        abstract class Animal{
            public abstract void eat();
        }
        public interface Milk{
            void makeMilk();
        }
        public interface Hunt{
            void huntAninmal();
        }
        public interface Fly{
            void flyUpHigh();
        }
        public class 奶牛 extends Animal implements Milk{
            @Override
            public void eat(){
                System.out.println("老娘吃的是草");
            }
            @Override
            public void makeMilk(){
                System.out.println("老娘产的是奶");
            }
        }
        public class 老虎 extends Animal implements Hunt{
		@Override
		public void eat() {
			System.out.println("老爷吃的是牛");
		}
		@Override
		public void huntAninmal() {
			System.out.println("老爷猎的是牛");
		}
        }
        public class 蝴蝶 extends Animal implements Fly{
		@Override
		public void eat() {
			System.out.println("老子吃的是屎");
		}
		@Override
		public void flyUpHigh() {
			System.out.println("老子要上天!!!");
		}
        }
        public static void main(String[] args) {
		AbsIT1 t = new AbsIT1();
		奶牛 n = t.new 奶牛();
		老虎 l = t.new 老虎();
		蝴蝶 h = t.new 蝴蝶();
		n.eat();
		n.makeMilk();
		l.eat();
		l.huntAninmal();
		h.eat();
		h.flyUpHigh();
        }
    }
    
    老娘吃的是草
    老娘产的是奶
    老爷吃的是牛
    老爷猎的是牛
    老子吃的是屎
    老子要上天!!!
    ```

#### 10.[Android]如何导入已有的外部数据库
[Android如何导入已有的外部数据库 GIT上也保存了](https://www.cnblogs.com/xiaowenji/archive/2011/01/03/1925014.html)
- 我们开发的APP,假设 packageName是 com.currpackage.name ,则其sqlite数据库文件在手机内部存储中的路径L是  /data/data/com.currpackage.name/.
- 首先将外部数据库文件 out.db 放在 res/raw下,然后构建 InputStream读取 out.db;
- 然后构建L下的数据库文件 out.db 的FileOutputStram,将原始db文件中的数据写入到L下的 out.db 下即可.
    ```
    //构建已经存在的外部数据库文件的InputStream 和 要写入的App数据库文件的FileOutputStrean
    InputStream is = this.context.getResources().openRawResource(R.raw.out);
    String DB_PATH = "/data"+ Environment.getDataDirectory().getAbsolutePath() + "/" 
        + PACKAGE_NAME + "/out.db";
    FileOutputStream fos = new FileOutputStream(dbfile);
    //不断读取,写入新文件
    byte[] buffer = new byte[BUFFER_SIZE];
    int count = 0;
    while ((count = is.read(buffer)) > 0) {
        fos.write(buffer, 0, count);
    }
    fos.close();
    is.close();
    ```

#### 11.本地广播和全局广播的区别
1. 本地广播:
    - 不被其他应用程序获取,也不能响应其他应用的本地广播,不用担心隐私数据泄露,也不用担心其他应用伪造广播造成安全隐患
    - 本地广播相比全局广播更高效
    - 本地广播只能被动态注册,动态注册或方法时需要用到LocalBroadcastManager,不能在AndroidManifest.xml静态注册
        > 因为静态注册是要是让程序在未启动的情况下也能接受广播，发送本地广播的时候程序必然是已经启动的状态
    - 本地广播的实现原理其实就是 LocalBroadcastManager利用HashMap和List来维护广播接收者、IntentFileter、Intent三者之间的关系
        > LocalBroadcastManager.getInstance是用单例模式获取了整个App中唯一的LocalBroadcastManager实例
2. 全局广播:
    - 发送的全局广播可被其他应用程序获取,也能获取其他应用程序发送的全局广播
    - 全局广播既可以动态注册,也可以静态注册.
3. 全局广播及本地广播代码实例
    ```
    工程P1:
    public class MainActivity extends AppCompatActivity {
        private TextView tv_all,tv_local;
        //响应全局广播的BroadcastReceiver
        private BroadcastReceiver globalReceiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                if (intent.getAction().equalsIgnoreCase("global")){
                    tv_all.setText("global:全局广播已经收到:"+intent.getStringExtra("data"));
                }
            }
        };
        //响应本地广播的BroadcastReceiver
        private BroadcastReceiver localBroadReceiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                tv_local.setText("local:本地广播已经收到:"+intent.getStringExtra("data"));
            }
        };
    
        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main);
            tv_all = findViewById(R.id.tv_all);
            tv_local = findViewById(R.id.tv_local);
            //注册全局广播
            registerReceiver(globalReceiver,new IntentFilter("global"));
            //注册本地广播
            LocalBroadcastManager.getInstance(this).registerReceiver(localBroadReceiver,new IntentFilter("localBroadCast"));
        }
    
        @Override
        protected void onDestroy() {
            super.onDestroy();
            //解除全局广播注册
            unregisterReceiver(globalReceiver);
            //解除本地广播注册
            LocalBroadcastManager.getInstance(this).unregisterReceiver(localBroadReceiver);
        }
    
        public void go2(View view) {
            startActivity(new Intent(this,A2.class));
        }
    }
    public class A2 extends AppCompatActivity {
        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_a2);
        }
        /**
         * 发送本地广播
         * @param view
         */
        public void sendLocalB(View view) {
            //发送本地广播
            Intent intent = new Intent("localBroadCast");
            intent.putExtra("data","localBroadCastTest");
            LocalBroadcastManager.getInstance(this).sendBroadcast(intent);
        }
        /**
         * 发送全局广播
         * @param view
         */
        public void sendGlobalB(View view) {
            Intent intent = new Intent("global");
            intent.putExtra("data","globalTest");
            sendBroadcast(intent);
        }
    }
    
    工程P2:
    public class MainActivity extends AppCompatActivity {
        private TextView tv_all,tv_local;
        private BroadcastReceiver globalReceiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                if (intent.getAction().equalsIgnoreCase("global")){
                    tv_all.setText("global:全局广播已经收到:"+intent.getStringExtra("data"));
                }
            }
        };
        private BroadcastReceiver localBroadReceiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                tv_local.setText("local:本地广播已经收到:"+intent.getStringExtra("data"));
            }
        };
        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main);
            tv_all = findViewById(R.id.tv_all);
            tv_local = findViewById(R.id.tv_local);
            //注册全局广播
            registerReceiver(globalReceiver,new IntentFilter("global"));
            //注册本地广播
            LocalBroadcastManager.getInstance(this).registerReceiver(localBroadReceiver,new IntentFilter("localBroadCast"));
        }
        @Override
        protected void onDestroy() {
            super.onDestroy();
            unregisterReceiver(globalReceiver);
            LocalBroadcastManager.getInstance(this).unregisterReceiver(localBroadReceiver);
        }
    }
    
    //经试验:
    在工程P1中发送全局广播,P1和P2都可以接收到广播并响应;
    在工程P1中发送本地广播,只有P1可以接收到;
    ```
    
#### 12.AIDL,进程间通信,Binder

#### 13.IntentService作用是什么
1. 生成一个默认的且与主线程互相独立的工作者线程来执行所有传送至onStartCommand() 方法的Intetnt,在所有的请求(Intent)都被执行完以后会自动停止服务，所以，你不需要自己去调用stopSelf()方法来停止
2. 多个线程同时调用IntentService,循环发送多个Intent,IntentService会全部处理完毕,再自行结束自己
    ```
    Log.e("Jet","MainActivity Thread id is:"+Thread.currentThread().getId());
    //        startService(new Intent(this,MyIntentService.class));
    new Thread(new Runnable() {
        @Override
        public void run() {
            for(int i=0;i<10;i++){
                Intent intent = new Intent(MainActivity.this,MyIntentService.class);
                intent.setAction("Thread1:"+i);
                startService(intent);
            }
        }
    }).start();
    new Thread(new Runnable() {
        @Override
        public void run() {
            for(int i=0;i<10;i++){
                Intent intent = new Intent(MainActivity.this,MyIntentService.class);
                intent.setAction("Thread2:"+i);
                startService(intent);
            }
        }
    }).start();
    new Thread(new Runnable() {
        @Override
        public void run() {
            for(int i=0;i<10;i++){
                Intent intent = new Intent(MainActivity.this,MyIntentService.class);
                intent.setAction("Thread3:"+i);
                startService(intent);
            }
        }
    }).start();
    
    public class MyIntentService extends IntentService{
        public MyIntentService() {
            this("MyIntentService");
        }
        public MyIntentService(String name) {
            super(name);
        }
        @Override
        protected void onHandleIntent(@Nullable Intent intent) {
            Log.e("Jet","MyIntentService Thread id is:"+Thread.currentThread().getId());
        }
        @Override
        public void onDestroy() {
            super.onDestroy();
            Log.e("Jet","MyIntentService:onDestroy;");
        }
    }
    
    E/Jet: MainActivity Thread id is:1
    E/Jet: MyIntentService Thread id is:6601
    E/Jet: MyIntentService Thread id is:6601
        MyIntentService Thread id is:6601
    E/Jet: MyIntentService Thread id is:6601
    E/Jet: MyIntentService Thread id is:6601
    E/Jet: MyIntentService Thread id is:6601
    E/Jet: MyIntentService Thread id is:6601
    E/Jet: MyIntentService Thread id is:6601
    E/Jet: MyIntentService Thread id is:6601
        MyIntentService Thread id is:6601
    E/Jet: MyIntentService Thread id is:6601
        MyIntentService Thread id is:6601
    E/Jet: MyIntentService Thread id is:6601
    E/Jet: MyIntentService Thread id is:6601
    E/Jet: MyIntentService Thread id is:6601
    E/Jet: MyIntentService Thread id is:6601
    E/Jet: MyIntentService Thread id is:6601
    E/Jet: MyIntentService Thread id is:6601
        MyIntentService Thread id is:6601
    E/Jet: MyIntentService Thread id is:6601
        MyIntentService Thread id is:6601
        MyIntentService Thread id is:6601
    E/Jet: MyIntentService Thread id is:6601
    E/Jet: MyIntentService Thread id is:6601
    E/Jet: MyIntentService Thread id is:6601
        MyIntentService Thread id is:6601
    E/Jet: MyIntentService Thread id is:6601
        MyIntentService Thread id is:6601
    E/Jet: MyIntentService Thread id is:6601
        MyIntentService Thread id is:6601
        
    //所有Intent处理完后自行结束
    E/Jet: MyIntentService:onDestroy;
    ```

#### 14.Activity的启动模式
1. Activity的LaunchMode
    1. standard:默认模式.每次都创建新的Activity实例,被创建的Activity会进入启动它的那个Activity所在的任务栈中.
        > 当我们使用ApplicationContext启动一个standard模式的Activity会报错,因为非Activity类型的Context并没有所谓的任务栈,解决办法是为待启动的Activity指定FLAG_ACTIVITY_NEW_TASK标记,这样启动的时候会为Activity创建一个新的任务栈,实际以"singleTask"模式启动;
        ```
        在Application中
        Intent intent = new Intent(this,TargetActivity.class);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        this.startActivity(intent);
        ```
    2. singleTop:栈顶复用模式.当被启动的Activity是singleTop,且位于启动它的Activity所属任务栈的栈顶,则不新建,调用onNewIntent,否则新建Activity实例.
        - ABCD-->D-->ABCD
        - ABDC-->D-->ABDCD
    3. singleTask:栈内复用模式.**只要Activity在任意1个任务栈中存在,多次启动此Activity都不会重新创建实例**,会调用其onNewIntent.且singleTask默认有clearTop的效果:ADBC-->D(D是singleTask)-->AD.具体流程如下:
        - 如果A和其所需的任务栈S都不存在,则会先创建S,再创建A,将A压入S中;
        - 如果S存在,A未创建,则创建A,将A压入S中;
        - 如果S存在,且A已经在S中,比如S中是 BCADE,则会将A切换到栈顶,调用其onNewIntent,并将A上面的DE清除,变成BCA
    4. singleInstance:单实例模式.是一种singleTask的加强版.singleInstance模式的Activity只能单独存在一个任务栈中.创建后多次调用都会执行其onNewIntent.
2. Activity的TaskAffinity
    1. 1个Activity所需的任务栈的名称,由该Activity的TaskAffinity决定.默认情况下,所有Activity的任务栈的名称是应用的包名.
    2. 我们可以为1个Activity指定单独的TaskAffinity属性,必须不能和包名相同.
        ```
        <activity android:name="com.jet.project1.ViewPagerTransformerActivity"
            android:taskAffinity="@string/crash_with_delay"/>
        ```
    3. TaskAffinity和singleTask配对使用才有意义,其他情况无效.此时设置过的Activity会运行在TaskAffinity指定的任务栈中.
        ```
        A为standard,B,C为singleTask且设置了android:taskAffinity="a.b.c.name",
        启动A,A启动B,B启动C,C启动A,A启动B.
        此时按两次BACK,结果是回到桌面.
        
        解析:
        1: A运行于包名指定的任务栈AppName中;
        2: A启动B,因为B,C都指定了taskAffinity且是singleTask,所以会先创建任务栈S(a.b.c.name),再创建B,将B压入;
        3: B启动C,C所属的任务栈S已经存在,创建C,压入S顶部
        4: C启动A,A是standard,再创建1个A,压入C所在的任务栈S顶部,此时S中是:BCA
        5: A启动B,B是singleTask,B在S中,并将B切换到栈顶,执行其onNewIntent.singleTask具有clearTop效果,B上面的CA被移除,S中变成B
        
        此时按两次BACK
        
        第一次BACK,S中的B出栈,S已不存在,回到后台任务栈,将AppName显示出来.AppName中仅有A;
        第二次BACK,AppName中的A也出栈,AppName也不存在了,回到了桌面.
        ```
3. 不同场景选择的LaunchMode
    1. 点击通知启动的内容显示页面:singleTop
    2. 程序入口:singleTask,栈内多次启动,不会重复创建,且自动移除上面的Activity.
    3. 闹铃的响铃界面:singleInstance.


#### 15.Android 事件传递机制

#### 16.Android View绘制流程
- [参考](http://www.codekk.com/blogs/detail/54cfab086c4761e5001b253f)
- 

#### 17.多线程,Handler,Thread和HandlerThread,线程同步

#### 18.什么情况导致内存泄漏
1. 内存泄漏和内存溢出
    - 内存泄露是指无用对象持续占有内存或无用对象的内存得不到及时释放,从而造成的内存空间的浪费称为内存泄露:memory leak
    - 内存溢出是程序在申请内存时,没有足够的内存空间供其使用:out of memory
    - 内存泄漏数量足够大,就会引起内存溢出.或者说内存泄漏是内存溢出的原因之一.
2. 什么情况导致内存泄漏:凡是没有及时释放内存的情况都应该叫做内存泄漏,如何防止
    - 资源对象使用结束要及时关闭,如:InputStream,OutPutStream,SQLiteCursor要及时close
    - ListView要使用convertView,不要重复创建View
    - Bitmap不再使用,主动调用其recycle释放内存
    - 在Activity中注册BroadCastReceiver在onDestroy中解除注册:unregisterReceiver(BroadcastReceiver)
    - 当集合里面的对象属性被修改后,再调用remove()方法时不起作用.为了可以及时移除集合中的对象,对象在存入集合后属性不应该再做变更,看HashSet,HashMap的源码:
        ```java
        HashSet:
        private transient HashMap<E,Object> map;
        public boolean remove(Object o) {
            return map.remove(o)==PRESENT;
        }
        
        HashMap:
        public V remove(Object key) {
            Node<K,V> e;
            return (e = removeNode(hash(key), key, null, false, true)) == null ?
                null : e.value;
        }
        ```
        可见HashSet执行remove最终是执行HashMap.remove.根据传入参数的hash值来移除数据.<br>
        当已经存入集合中的对象属性改变,其hash也会变化,HashMap就无法根据已经变化的Hash找到最初存储时的index.
    - 其他防止内存泄漏的情况待续

#### 19.性能优化
1. [胡凯](http://hukai.me/android-performance-patterns/)
2. [anly_jun](https://juejin.im/post/581f4ad667f3560058a33057)
3. [Carson_Ho](https://www.jianshu.com/p/516effe7649d)

#### 20.ANR
> ANR全名Application Not Responding, 也就是"应用无响应". 
1. 为何差生ANR:
    - 在主线程(UI线程)做了太多阻塞式耗时操作:文件读写,数据库读写等
    - 其他
2. ANR分析:
    - [anly_jun](https://www.jianshu.com/p/6d855e984b99) 
    - 一定要学会怎么导出trace文件,怎么分析trace文件
3. 如何避免ANR:不要再主线程做耗时操作
    - 那些代码是执行在主线程?
        1. Activity所有的生命周期回调
        2. Service默认执行在主线程
        3. BroadcastReceiver的onReceive
        4. 没有使用子线程的Looper创建的Handler,其handleMessage,post(Runnable)执行在主线程
        5. AsyncTask中除了doInBackgrouund的其他方法
        6. View的post(Runnable)是执行在主线程
    - 如何避免ANR:
        1. 耗时操作新建Thread执行
        2. 使用AsyncTask时,耗时操作写在doInBackground
        3. Service是运行在主线程中,可以使用IntentService代替Service,执行完毕会自动关闭
